---
layout: post
title: Lock Free Programming
date: '2008-03-02T17:56:00.000+09:00'
author: jeremyko
tags:
- c++
- lock free
modified_time: '2017-01-01T00:04:53.380+09:00'
blogger_id: tag:blogger.com,1999:blog-7360229670252766698.post-2148454786127591482
blogger_orig_url: https://jeremyko.blogspot.com/2008/03/lock-free-programming.html
---

<span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><span style="background-color: white; line-height: 18px; text-align: left;">멀티 쓰레드 환경에서, 데이터의 일관성 및 원하는 결과로 데이터를 처리하기 위해서,&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">반드시 동기화 기법이 사용된다. 대부분 lock을 이용한 동기화 처리를 하게 된다.&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">하지만 공유 자원에 대해서 lock 을 사용할때 잘못하면 DeadLock 같은 문제 상황이&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">생길수도 있다. 동시성을 제한하는 lock 의 존재라는 것은 자칫 멀티쓰레드의&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">이점과는 상반되는 의미로 작용할 경우가 많다.&nbsp;</span>공유된 자원을 멀티 쓰레드 환경에서 사용시에는 대부분 아래와 같이 동기화 처리를 하게 된다.&nbsp;</span><br /><div style="padding: 10px; text-align: left;"><br /><table border="0" cellpadding="0" cellspacing="0" style="background-color: #001b33; color: black; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; position: relative; z-index: 100;"><tbody><tr><td style="vertical-align: top;"><pre class="textmate-source-numbers" style="color: #999999; font-family: 'Bitstream Vera Sans Mono', Inconsolata, Monaco, Consolas, 'Courier New', monospace; font-size: 11px; line-height: 1.3em; margin-top: 0em; padding-right: 1.25em; text-align: right;">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br /></pre></td><td style="vertical-align: top;"><pre class="textmate-source" style="color: white; font-family: 'Bitstream Vera Sans Mono', Inconsolata, Monaco, Consolas, 'Courier New', monospace; font-size: 11px; line-height: 1.3em; margin-top: 0em; padding: 0px; word-wrap: break-word;"><pre class="sunburst" style="font-family: 'Bitstream Vera Sans Mono', Inconsolata, Monaco, Consolas, 'Courier New', monospace; line-height: 1.3em; margin-top: 0em;"><span class="storage storage_type storage_type_template storage_type_template_c++" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">template </span>&lt;<span class="meta meta_class-struct-block meta_class-struct-block_c++" style="padding-bottom: 0.1em; padding-top: 0.2em;"><span class="storage storage_type storage_type_c++" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">class</span> <span class="entity entity_name entity_name_type entity_name_type_c++" style="color: #ffdd00; padding-bottom: 0.1em; padding-top: 0.2em;">K</span>, <span class="meta meta_class-struct-block meta_class-struct-block_c++" style="padding-bottom: 0.1em; padding-top: 0.2em;"><span class="storage storage_type storage_type_c++" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">class</span> <span class="entity entity_name entity_name_type entity_name_type_c++" style="color: #ffdd00; padding-bottom: 0.1em; padding-top: 0.2em;">V</span></span></span>&gt;<br /><span class="meta meta_class-struct-block meta_class-struct-block_c++" style="padding-bottom: 0.1em; padding-top: 0.2em;"><span class="storage storage_type storage_type_c++" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">class</span> <span class="entity entity_name entity_name_type entity_name_type_c++" style="color: #ffdd00; padding-bottom: 0.1em; padding-top: 0.2em;">WRRMMap</span><br />{<br /><span class="storage storage_modifier storage_modifier_c++" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">public:</span><br />   map &lt; K,V&gt;* pMap;<br /><br /><span class="storage storage_modifier storage_modifier_c++" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">public:</span><br /><br />    V<span class="meta meta_function meta_function_c" style="padding-bottom: 0.1em; padding-top: 0.2em;"> <span class="entity entity_name entity_name_function entity_name_function_c" style="color: #ffdd00; padding-bottom: 0.1em; padding-top: 0.2em;">Lookup</span> <span class="meta meta_parens meta_parens_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">(<span class="storage storage_modifier storage_modifier_c" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">const</span> K&amp; k)</span><br />    <span class="meta meta_block meta_block_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">{<br />        CSomeLockPbj lockObj; <span class="comment comment_line comment_line_double-slash comment_line_double-slash_c++" style="color: #0088ff; font-style: italic; padding-bottom: 0.1em; padding-top: 0.2em;">// 지역 범위의 lock 객체</span><br />        <span class="keyword keyword_control keyword_control_c" style="color: #ff9d00; padding-bottom: 0.1em; padding-top: 0.2em;">return</span> (*pMap)[k];<br />    }</span></span>       <br /><br />    <span class="storage storage_type storage_type_c" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">void</span><span class="meta meta_function meta_function_c" style="padding-bottom: 0.1em; padding-top: 0.2em;"> <span class="entity entity_name entity_name_function entity_name_function_c" style="color: #ffdd00; padding-bottom: 0.1em; padding-top: 0.2em;">Updtate</span><span class="meta meta_parens meta_parens_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">( <span class="storage storage_modifier storage_modifier_c" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">const</span> K&amp; k, <span class="storage storage_modifier storage_modifier_c" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">const</span> V&amp; v)</span><br />    <span class="meta meta_block meta_block_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">{ <br />        CSomeLockPbj lockObj; <span class="comment comment_line comment_line_double-slash comment_line_double-slash_c++" style="color: #0088ff; font-style: italic; padding-bottom: 0.1em; padding-top: 0.2em;">// 지역 범위의 lock 객체</span><br />        (* pMap)[k] = v;                <br />    }</span></span><br />}</span>;</pre></pre></td></tr></tbody></table><br /><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br /></span><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">예를 들어 어떤 map 객체가 공유되어야 한다면 CSomeLockPbj  처럼 지역 범위의 lock 객체를 사용해서 동기화 처리를 한다고 가정한다. 그런데, 데이터를 읽을때나 실제로 변경할때나 모두 lock 을 잡고 처리해야 하는 이런 구조는 성능상의 문제를 가져오게 될것이다. 또한, 위의 예처럼 공유 데이터의 lock을 처리하는 시점을 프로그래밍시에 판단하는거 자체가 쉽지 않은 일이다. 즉, lock을 쓰는것으로 인한 성능상의 문제이전에, 올바르게 lock을 잡아서 써야하는 판단 자체가 어렵다. 그럼 대안은 어떤것이 있을까? </span></div><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br style="background-color: white; line-height: 18px; text-align: left;" /></span><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><span style="background-color: white; line-height: 18px; text-align: left;">lock free (혹은 non blocking ) 자료구조를 사용하는 것이다.&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">위의 코드를 Lock Free 방식으로 다시 써보면&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">&nbsp;</span></span><br /><span style="background-color: white; color: #555555; font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif; font-size: 12px; line-height: 18px; text-align: left;"></span><br /><div class="allcode" style="background-color: #001b33; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; overflow: auto; width: 645.96875px;"><table border="0" cellpadding="0" cellspacing="0" style="background-color: transparent; background-position: initial initial; background-repeat: initial initial; position: relative; z-index: 100;"><tbody><tr><td style="vertical-align: top;"><pre class="textmate-source-numbers" style="color: #999999; font-family: 'Bitstream Vera Sans Mono', Inconsolata, Monaco, Consolas, 'Courier New', monospace; font-size: 11px; line-height: 1.3em; margin-top: 0em; padding-right: 1.25em; text-align: right;">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39<br /></pre></td><td style="vertical-align: top;"><pre class="textmate-source" style="color: white; font-family: 'Bitstream Vera Sans Mono', Inconsolata, Monaco, Consolas, 'Courier New', monospace; font-size: 11px; line-height: 1.3em; margin-top: 0em; padding: 0px; word-wrap: break-word;"><pre class="sunburst" style="font-family: 'Bitstream Vera Sans Mono', Inconsolata, Monaco, Consolas, 'Courier New', monospace; line-height: 1.3em; margin-top: 0em;"><span class="storage storage_type storage_type_template storage_type_template_c++" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">template </span>&lt;<span class="meta meta_class-struct-block meta_class-struct-block_c++" style="padding-bottom: 0.1em; padding-top: 0.2em;"><span class="storage storage_type storage_type_c++" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">class</span> <span class="entity entity_name entity_name_type entity_name_type_c++" style="color: #ffdd00; padding-bottom: 0.1em; padding-top: 0.2em;">K</span>, <span class="meta meta_class-struct-block meta_class-struct-block_c++" style="padding-bottom: 0.1em; padding-top: 0.2em;"><span class="storage storage_type storage_type_c++" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">class</span> <span class="entity entity_name entity_name_type entity_name_type_c++" style="color: #ffdd00; padding-bottom: 0.1em; padding-top: 0.2em;">V</span></span></span>&gt;<br /><span class="meta meta_class-struct-block meta_class-struct-block_c++" style="padding-bottom: 0.1em; padding-top: 0.2em;"><span class="storage storage_type storage_type_c++" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">class</span> <span class="entity entity_name entity_name_type entity_name_type_c++" style="color: #ffdd00; padding-bottom: 0.1em; padding-top: 0.2em;">WRRMMap</span><br />{<br /><span class="storage storage_modifier storage_modifier_c++" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">public:</span><br />    map &lt; K,V&gt;* pMap;<br /> <br /><span class="storage storage_modifier storage_modifier_c++" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">public:</span><br />    <span class="storage storage_type storage_type_template storage_type_template_c++" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">template </span>&lt; <span class="meta meta_class-struct-block meta_class-struct-block_c++" style="padding-bottom: 0.1em; padding-top: 0.2em;"><span class="storage storage_type storage_type_c++" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">class</span> <span class="entity entity_name entity_name_type entity_name_type_c++" style="color: #ffdd00; padding-bottom: 0.1em; padding-top: 0.2em;">T</span></span>&gt;<br />    <span class="storage storage_type storage_type_c" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">bool</span><span class="meta meta_function meta_function_c" style="padding-bottom: 0.1em; padding-top: 0.2em;"> <span class="entity entity_name entity_name_function entity_name_function_c" style="color: #ffdd00; padding-bottom: 0.1em; padding-top: 0.2em;">CAS</span> <span class="meta meta_parens meta_parens_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">(T* addr, T exp, T val)</span><br />    <span class="meta meta_block meta_block_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">{<br />        <span class="comment comment_line comment_line_double-slash comment_line_double-slash_c++" style="color: #0088ff; font-style: italic; padding-bottom: 0.1em; padding-top: 0.2em;">// 비교후 바꾸는 과정이 하나의 원자적 단의로 이루어져야함</span><br />        <span class="keyword keyword_control keyword_control_c" style="color: #ff9d00; padding-bottom: 0.1em; padding-top: 0.2em;">if</span>( *addr == <span class="support support_function support_function_C99 support_function_C99_c" style="color: #ffb054; padding-bottom: 0.1em; padding-top: 0.2em;">exp</span>)<br />        <span class="meta meta_block meta_block_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">{<br />            *addr = val;<br />            <span class="keyword keyword_control keyword_control_c" style="color: #ff9d00; padding-bottom: 0.1em; padding-top: 0.2em;">return</span> <span class="constant constant_language constant_language_c" style="color: #ff0044; padding-bottom: 0.1em; padding-top: 0.2em;">true</span>;<br />        }</span>      <br />        <span class="keyword keyword_control keyword_control_c" style="color: #ff9d00; padding-bottom: 0.1em; padding-top: 0.2em;">return</span> <span class="constant constant_language constant_language_c" style="color: #ff0044; padding-bottom: 0.1em; padding-top: 0.2em;">false</span>;<br />    }</span></span>  <br /><br />    V<span class="meta meta_function meta_function_c" style="padding-bottom: 0.1em; padding-top: 0.2em;"> <span class="entity entity_name entity_name_function entity_name_function_c" style="color: #ffdd00; padding-bottom: 0.1em; padding-top: 0.2em;">Lookup</span> <span class="meta meta_parens meta_parens_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">(<span class="storage storage_modifier storage_modifier_c" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">const</span> K&amp; k)</span><br />    <span class="meta meta_block meta_block_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">{<br />        <span class="keyword keyword_control keyword_control_c" style="color: #ff9d00; padding-bottom: 0.1em; padding-top: 0.2em;">return</span> (*pMap)[k];<br />    }</span></span>       <br /><br />    <span class="storage storage_type storage_type_c" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">void</span><span class="meta meta_function meta_function_c" style="padding-bottom: 0.1em; padding-top: 0.2em;"> <span class="entity entity_name entity_name_function entity_name_function_c" style="color: #ffdd00; padding-bottom: 0.1em; padding-top: 0.2em;">Updtate</span><span class="meta meta_parens meta_parens_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">( <span class="storage storage_modifier storage_modifier_c" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">const</span> K&amp; k, <span class="storage storage_modifier storage_modifier_c" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">const</span> V&amp; v)</span><br />    <span class="meta meta_block meta_block_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">{ <br />        map &lt;K, V&gt;* pNew = <span class="constant constant_numeric constant_numeric_c" style="color: #ff0044; padding-bottom: 0.1em; padding-top: 0.2em;">0</span>;<br />        map &lt;K, V&gt;* pOld = <span class="constant constant_numeric constant_numeric_c" style="color: #ff0044; padding-bottom: 0.1em; padding-top: 0.2em;">0</span>;<br />        <span class="comment comment_line comment_line_double-slash comment_line_double-slash_c++" style="color: #0088ff; font-style: italic; padding-bottom: 0.1em; padding-top: 0.2em;">// 아래의 과정중  다른 쓰레드에 의해 pMap 는 변경될수있다.</span><br />        <span class="keyword keyword_control keyword_control_c" style="color: #ff9d00; padding-bottom: 0.1em; padding-top: 0.2em;">do</span><br />        <span class="meta meta_block meta_block_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">{<br />            pOld = pMap;<br />            delete pNew ;<br />            pNew = new map&lt;K,V&gt; (*pOld);          <br />            (* pNew)[k] = v;     <br /><br />        }</span> <span class="keyword keyword_control keyword_control_c" style="color: #ff9d00; padding-bottom: 0.1em; padding-top: 0.2em;">while</span>(!<span class="meta meta_function-call meta_function-call_c" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;"><span class="support support_function support_function_any-method support_function_any-method_c" style="color: #ffb054; padding-bottom: 0.1em; padding-top: 0.2em;">CAS</span> (</span>&amp;pMap, pOld, pNew));<br />    }</span></span><br />}</span>;</pre></pre></td></tr></tbody></table></div><span style="background-color: white; color: #555555; font-family: &quot;verdana&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif; font-size: 12px; line-height: 18px; text-align: left;">&nbsp;&nbsp;</span><br /><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><span style="background-color: white; line-height: 18px; text-align: left;">이런식으로 쓸수있다.&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">이것은 어떠한 공유된 데이터에 접근할때 lock을 걸고&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">모든 다른 쓰레드의 접근을 막아놓고 자기할일을 하는 방식이 아니다.&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">먼저 데이터를 복제후 자신의 처리를 수행하고 수정된 데이터를&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">다시 원래의 것과 교체하는 식으로 이루어진다.&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">하지만 생각해보면 데이터 복제후 자신만의 처리를 한이후에&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">그데이터가 다른 쓰레드에 의해 변경된 경우가 발생할수 있다.&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">이때는 어떤 처리를 해야 할것인가?</span></span><br /><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br style="background-color: white; line-height: 18px; text-align: left;" /></span><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><span style="background-color: white; line-height: 18px; text-align: left;">이경우, 모든일을 다시 처음부터 반복한다.&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">즉 다시시도하기 ( 위의 예처럼 대개 loop처리) 를 통해서 구현된다.&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">데이터를 다시 복사하고 자신의 처리를 한 다음 ,&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">처리 후 시점에 자신이 복사했던 그 데이터가 변경이 일어나지 않았다는것을 확인하고,&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">변경 없음이 확인되면 원래의 데이터를 자신이 변경한 데이터로 바꾸는 것이다.</span></span><br /><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br style="background-color: white; line-height: 18px; text-align: left;" /></span><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><span style="background-color: white; line-height: 18px; text-align: left;">그러면, 이때 원래의 데이터와 자신의 변경시킨 데이터를 서로 비교하고,&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">변경이 없다면 원래데이터를 자신의 그것으로 교체하는작업은&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">하나의 원자적 단의로 이루어져야 할것이다.&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">이때 비교 후 교체 의 연산이 원자적으로 이루어져야 한다는것이 가장 중요한 핵심이다.&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">여기서 lock free 처리방식에서 가장 일반적으로 사용되는 CAS (Compare and Swap)&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">이라는 개념이 등장한다.</span></span><br /><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br style="background-color: white; line-height: 18px; text-align: left;" /></span><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><span style="background-color: white; line-height: 18px; text-align: left;">위의 코드에서처럼, CAS 의 내부구조는 매우 간단하다.&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">주어진 포인터를 비교하고, 틀리면 실패, 맞으면(즉, 자신의 처리시작 시점과&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">데이터가 동일하다면)&nbsp; 기존 데이터를 자신의 것으로 바꾸고 성공을 리턴한다.&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">이모든것이 하나의 원자적 단위로 처리되어야 한다는 것이 중요하다. </span><span style="background-color: white; line-height: 18px; text-align: left;">윈도우즈 API에서 이러한 목적에 사용할수 있는 것들은, 다들 알고 있는&nbsp;</span><span style="background-color: white; line-height: 18px; text-align: left;">다음과 같은 것들이 되겠다.</span></span><br /><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms686360(v=vs.85).aspx" style="background-color: white; line-height: 18px; text-align: left; text-decoration: none;" target="_blank"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">Windows atomic compare and exchange API</span></a><br /><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br style="background-color: white; line-height: 18px; text-align: left;" /></span><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br />윈도우즈 경우 위의 코드를 다시 작성하면,  다음처럼 될것이다.   </span><br /><br /><div class="allcode" style="background-color: #001b33; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; overflow: auto; width: 645.96875px;"><table border="0" cellpadding="0" cellspacing="0" style="background-color: transparent; background-position: initial initial; background-repeat: initial initial; position: relative; z-index: 100;"><tbody><tr><td style="vertical-align: top;"><pre class="textmate-source-numbers" style="color: #999999; font-family: 'Bitstream Vera Sans Mono', Inconsolata, Monaco, Consolas, 'Courier New', monospace; font-size: 11px; line-height: 1.3em; margin-top: 0em; padding-right: 1.25em; text-align: right;">1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br /></pre></td><td style="vertical-align: top;"><pre class="textmate-source" style="color: white; font-family: 'Bitstream Vera Sans Mono', Inconsolata, Monaco, Consolas, 'Courier New', monospace; font-size: 11px; line-height: 1.3em; margin-top: 0em; padding: 0px; word-wrap: break-word;"><pre class="sunburst" style="font-family: 'Bitstream Vera Sans Mono', Inconsolata, Monaco, Consolas, 'Courier New', monospace; line-height: 1.3em; margin-top: 0em;"><span class="storage storage_type storage_type_c" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">void</span><span class="meta meta_function meta_function_c" style="padding-bottom: 0.1em; padding-top: 0.2em;"> <span class="entity entity_name entity_name_function entity_name_function_c" style="color: #ffdd00; padding-bottom: 0.1em; padding-top: 0.2em;">Updtate</span><span class="meta meta_parens meta_parens_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">( <span class="storage storage_modifier storage_modifier_c" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">const</span> K&amp; k, <span class="storage storage_modifier storage_modifier_c" style="color: #ffee80; padding-bottom: 0.1em; padding-top: 0.2em;">const</span> V&amp; v)</span><br /><span class="meta meta_block meta_block_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">{ <br />    map &lt;K, V&gt;* pNew = <span class="constant constant_numeric constant_numeric_c" style="color: #ff0044; padding-bottom: 0.1em; padding-top: 0.2em;">0</span>;<br />    map &lt;K, V&gt;* pOld = <span class="constant constant_numeric constant_numeric_c" style="color: #ff0044; padding-bottom: 0.1em; padding-top: 0.2em;">0</span>;<br />    <span class="comment comment_line comment_line_double-slash comment_line_double-slash_c++" style="color: #0088ff; font-style: italic; padding-bottom: 0.1em; padding-top: 0.2em;">// 아래의 과정중  다른 쓰레드에 의해 pMap는 변경될수있다.</span><br />    <span class="keyword keyword_control keyword_control_c" style="color: #ff9d00; padding-bottom: 0.1em; padding-top: 0.2em;">do</span><br />    <span class="meta meta_block meta_block_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">{<br />        pOld = pMap;<br />        delete pNew ;<br />        pNew = new map&lt;K,V&gt; (*pOld);          <br />        (* pNew)[k] = v;     <br /><br />    }</span> <span class="keyword keyword_control keyword_control_c" style="color: #ff9d00; padding-bottom: 0.1em; padding-top: 0.2em;">while</span>( (LONG) pOld  !=<br /><span class="meta meta_function meta_function_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">     <span class="entity entity_name entity_name_function entity_name_function_c" style="color: #ffdd00; padding-bottom: 0.1em; padding-top: 0.2em;">::InterlockedCompareExchange</span><span class="meta meta_parens meta_parens_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">(<br />                        (LONG*)</span>&amp; pMap,<br />                        <span class="meta meta_parens meta_parens_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">(LONG)</span>   pNew , <br />                        <span class="meta meta_parens meta_parens_c" style="padding-bottom: 0.1em; padding-top: 0.2em;">(LONG)</span>   pOld ) );</span><br />}</span></span>  <span class="comment comment_line comment_line_double-slash comment_line_double-slash_c++" style="color: #0088ff; font-style: italic; padding-bottom: 0.1em; padding-top: 0.2em;">// 결국 spin lock 처럼 처리되고 있다.</span><br />...</pre></pre></td></tr></tbody></table></div><br /><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">만약 garbage colle<span style="background-color: white; line-height: 18px;">ctor 가 지원되는 언어 (C#...) 라면 매우 편리해진다.&nbsp;</span><span style="background-color: white; line-height: 18px;">이전의 old 데이터는 더이상 참조되지 않으면 자동으로 메모리에서 해제될 것이기 </span><span style="background-color: white; line-height: 18px;">때문이다. 하지만 언어적으로 지원이 안되면, 위의 코드에서 Updtate 함수가 실행되면&nbsp;</span><span style="background-color: white; line-height: 18px;">이전 데이터는 더이상 참조되지 않지만 메모리에서 해제 되지 않는 상태로 계속&nbsp;</span><span style="background-color: white; line-height: 18px;">누적되게 된다. 그리고 위의 Updtate 함수에서 pOld = pMap; 이후에 만약 계속해서&nbsp;</span><span style="background-color: white; line-height: 18px;">context switching 이 발생시에는 처리가 언제 끝날지 알수 없는 문제가 될 수도&nbsp;</span><span style="background-color: white; line-height: 18px;">있을것이다.&nbsp;</span><span style="background-color: white; line-height: 18px;">기존의 lock을 사용하는 방식은 lock free 방식에 비해 사용하기 간단한 반면,&nbsp;</span><span style="background-color: white; line-height: 18px;">쓰레드가 증가할수록 점점 더 성능의 병목현상, deadlock 발생등의 문제점이 있고&nbsp;</span><span style="background-color: white; line-height: 18px;">그에 비해 lock free방식은 기존의 방식과 차이점으로 인해 익숙해지기가 쉽지 않지만&nbsp;</span><span style="background-color: white; line-height: 18px;">새로운 해결책이 될 수 도 있을것이다.</span></span><br /><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br /></span><span style="background-color: white; color: #555555; font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif; font-size: 12px; line-height: 18px; text-align: left;">참고자료</span><br /><span style="background-color: white; color: #555555; font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif; font-size: 12px; line-height: 18px; text-align: left;"><a href="http://erdani.org/book/main.html" style="color: #909090; text-decoration: none;" target="_blank">Modern C++ design</a>저자&nbsp;<a href="http://erdani.org/" style="color: #909090; text-decoration: none;" target="_blank">Andrei Alexandrescu</a>&nbsp;<a href="http://erdani.org/publications/cuj-2004-10.pdf" style="color: #909090; text-decoration: none;" target="_blank">기고문</a></span><br /><a href="http://www.research.ibm.com/people/m/michael/pubs.htm" style="background-color: white; color: #909090; font-size: 12px; line-height: 18px; text-align: left; text-decoration: none;" target="_blank"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">http://www.research.ibm.com/people/m/michael/pubs.htm</span></a><br /><a href="http://www.boyet.com/Articles/BlogArchivesByCategory/Algorithms.html" style="background-color: white; color: #909090; font-size: 12px; line-height: 18px; text-align: left; text-decoration: none;" target="_blank"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">http://www.boyet.com/Articles/BlogArchivesByCategory/Algorithms.html</span></a>