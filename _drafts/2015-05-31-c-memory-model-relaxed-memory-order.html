---
layout: post
title: C++ memory model - relaxed memory order
date: '2015-05-31T23:42:00.001+09:00'
author: jeremyko
tags:
- c++
- memory model
modified_time: '2016-11-04T15:35:13.767+09:00'
blogger_id: tag:blogger.com,1999:blog-7360229670252766698.post-5813828251015299178
blogger_orig_url: https://jeremyko.blogspot.com/2015/05/c-memory-model-relaxed-memory-order.html
---

<br /><div class="page" title="Page 146"><div class="layoutArea"><div class="column"><span style="font-family: &quot;newbaskerville&quot;; font-size: 10.000000pt; font-style: italic;">* sequentially consistent </span><span style="font-family: &quot;newbaskerville&quot;; font-size: 10.000000pt;">ordering&nbsp;</span><br /><span style="font-family: &quot;newbaskerville&quot;; font-size: 10.000000pt;">&nbsp; </span><span style="font-family: &quot;courier&quot;; font-size: 9.000000pt;">memory_order_seq_cst</span><span style="font-family: &quot;newbaskerville&quot;; font-size: 10.000000pt;"> : X86 인 경우 성능 부하가 상대적으로 적다.</span><br /><br /><span style="font-family: &quot;newbaskerville&quot;; font-size: 10.000000pt; font-style: italic;">* acquire-release </span><span style="font-family: &quot;newbaskerville&quot;; font-size: 10.000000pt;">ordering&nbsp;</span><br /><span style="font-family: &quot;newbaskerville&quot;; font-size: 10.000000pt;">&nbsp; :</span><span style="font-family: &quot;courier&quot;; font-size: 9.000000pt;">memory_order_consume</span><span style="font-family: &quot;newbaskerville&quot;; font-size: 10.000000pt;">,&nbsp;</span><br /><span style="font-family: &quot;newbaskerville&quot;; font-size: 10.000000pt;">&nbsp;&nbsp; </span><span style="font-family: &quot;courier&quot;; font-size: 9.000000pt;">memory_order_acquire</span><span style="font-family: &quot;newbaskerville&quot;; font-size: 10.000000pt;">,&nbsp;</span><br /><span style="font-family: &quot;newbaskerville&quot;; font-size: 10.000000pt;">&nbsp;&nbsp; </span><span style="font-family: &quot;courier&quot;; font-size: 9.000000pt;">memory_order_release</span><span style="font-family: &quot;newbaskerville&quot;; font-size: 10.000000pt;">,&nbsp;</span><br /><span style="font-family: &quot;newbaskerville&quot;; font-size: 10.000000pt;">&nbsp;&nbsp; </span><span style="font-family: &quot;courier&quot;; font-size: 9.000000pt;">memory_order_acq_rel</span><span style="font-family: &quot;newbaskerville&quot;; font-size: 10.000000pt;"> </span><br /><br />* <span style="font-family: &quot;newbaskerville&quot;; font-size: 10.000000pt; font-style: italic;">relaxed </span><span style="font-family: &quot;newbaskerville&quot;; font-size: 10.000000pt;">ordering&nbsp;</span><br /><span style="font-family: &quot;newbaskerville&quot;; font-size: 10.000000pt;">&nbsp;&nbsp; </span><span style="font-family: &quot;courier&quot;; font-size: 9.000000pt;">memory_order_relaxed</span><span style="font-family: &quot;newbaskerville&quot;; font-size: 10.000000pt;"></span></div></div></div><br /><br />(*) relaxed memory order<br /><br />//-----------------------------------------------------<br />http://www.codeproject.com/Articles/43510/Lock-Free-Single-Producer-Single-Consumer-Circular<br /><br />* Rules for the Relaxed Memory Model and Operations&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br /><br />Relaxed atomic opertions on the same variable,on the same thread <br />guarantee happens-before ordering within that same thread.&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br /><br />Operations on the same thread, on the same variable will not be reordered&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br /><br />For a synchronized ordering between threads there must be a pair of acquire - release.&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br /><br />Only the <b>modification order</b> of the atomic operations on a variable is communicated to other threads, <br />but as the relaxed memory operation does not use synchronize-with the result may surprise you...<br /><br />동일 쓰레드에서 동일 변수에 대한 연산만이 happens-before관계를 따른다. <br />(즉 reordering 안된다).<br />변경 순서만이 다른 쓰레드들과 공유된다! <br /><br />//-----------------------------------------------------<br />https://www.youtube.com/watch?v=gpsz8sc6mNU<br />Each memory location has a total modification order (however, this order cannot be observed directly)<br />• Memory operations performed by the same thread on the same memory location are not reordered with respect to the modification order.<br /><br />//-----------------------------------------------------<br />http://en.cppreference.com/w/cpp/atomic/memory_order<br />memory_order_relaxed &nbsp;&nbsp;&nbsp; <br />-&gt;Relaxed operation: <br />&nbsp; there are no synchronization or ordering constraints, only atomicity is required of this operation.<br /><br />Atomic operations tagged <span class="t-c"><span class="mw-geshi cpp source-cpp">memory_order_relaxed</span></span> are not synchronization operations, they do not order memory. They only  guarantee atomicity and  modification order consistency.<br /><br />Typical use for relaxed memory ordering is updating counters, such as the reference counters of <span class="t-lc"><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr" title="cpp/memory/shared ptr">std::shared_ptr</a></span>, since this only requires atomicity, but not ordering or synchronization.<br /><br />동기화 필요없이 원자적 처리만 필요한 경우,<br /><div class="mw-geshi t-example-code" dir="ltr" style="display: block; text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;vector&gt;</span><br /><span class="co2">#include &lt;iostream&gt;</span><br /><span class="co2">#include &lt;thread&gt;</span><br /><span class="co2">#include &lt;atomic&gt;</span><br />&nbsp;<br /><a href="http://en.cppreference.com/w/cpp/atomic/atomic"><span class="kw1755">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> cnt <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span><br />&nbsp;<br /><span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><br /><span class="br0">{</span><br />    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> n <span class="sy1">&lt;</span> <span class="nu0">1000</span><span class="sy4">;</span> <span class="sy2">++</span>n<span class="br0">)</span> <span class="br0">{</span><br />        cnt.<span class="me1">fetch_add</span><span class="br0">(</span><span class="nu0">1</span>, std<span class="sy4">::</span><span class="me2">memory_order_relaxed</span><span class="br0">)</span><span class="sy4">;</span><br />    <span class="br0">}</span><br /><span class="br0">}</span><br />&nbsp;<br /><span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span><br /><span class="br0">{</span><br />    <a href="http://en.cppreference.com/w/cpp/container/vector"><span class="kw1065">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/thread/thread"><span class="kw1784">std::<span class="me2">thread</span></span></a><span class="sy1">&gt;</span> v<span class="sy4">;</span><br />    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> n <span class="sy1">&lt;</span> <span class="nu0">10</span><span class="sy4">;</span> <span class="sy2">++</span>n<span class="br0">)</span> <span class="br0">{</span><br />        v.<span class="me1">emplace_back</span><span class="br0">(</span>f<span class="br0">)</span><span class="sy4">;</span><br />    <span class="br0">}</span><br />    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">auto</span><span class="sy3">&amp;</span> t <span class="sy4">:</span> v<span class="br0">)</span> <span class="br0">{</span><br />        t.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span><br />    <span class="br0">}</span><br />    <a href="http://en.cppreference.com/w/cpp/io/cout"><span class="kw1447">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"Final counter value is "</span> <span class="sy1">&lt;&lt;</span> cnt <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span><br /><span class="br0">}</span></pre><pre class="de1"><span class="br0">&nbsp;</span></pre></div></div>--&gt; 10000&nbsp; <br /><br />//-----------------------------------------------------<br />http://www.slideshare.net/jinuskr/concurrency-in-action-chapter-5<br />동일쓰레드, 동일변수 reordering 없다<br /><br />Atomic만 보장, not ordering 순서 보장 없음<br /><br />atomic &lt;int&gt; x,y;<br /><br />&lt;thread 1&gt;<br />x.store(17, memory_order_relaxed);<br />y.store(37, memory_order_relaxed);<br /><br />&lt;thread 2&gt; <br />y.load (memory_order_relaxed);<br />x.load (memory_order_relaxed);<br /><br />동일 쓰레드,동일 변수가 아닌 경우,순서를 보장해 주지 않음. (대신 빠름) (0,0), (0,17), (37,0), (37,17) 의 결과 중 하나 <br /><br />** 만약 기본 모델 memory_order_seq_cst을 사용한다면 behavior defined<br />Atomic, Ordering --&gt; x, y 순차적 순서가 보장됨. =&gt; (0,0), (0,17), (37,17) 의 결과 중 하나<br />(37,0) 은 불가능. y가 37로 읽혔다면 x 는 17이 보장됨.<br /><br />** release acquire 사용<br />Ordered loads &amp; stores <br />최소한의 오버헤드 (0,0), (0,17), (37,17) 의 결과 중 하나 <br /><br /><br />(*) Acquire-Release Memory model<br /><br />http://www.codeproject.com/Articles/43510/Lock-Free-Single-Producer-Single-Consumer-Circular<br /><br /><br /><br />- No guaranteed order for all atomic operations<br /><br />- Still, it has stronger synchronization orderings than relaxed<br /><br />- Guaranteed thread-pair ordering synchronization. I.e.between the thread that does release and the thread that does acquire<br /><br />- Reordering is restricted but still not sequential...<br />&nbsp; // thread_1: <br />&nbsp; y.store(true, std::memory_order_release);<br /><br />&nbsp; //thread_2:<br />&nbsp; while(!y.load(std::memory_order_acquire));<br /><br />&nbsp; It is guaranteed that thread_2 will, at some point, see that y is true and exit the while-loop. <br />&nbsp; The memory_order_release synchronizes with the memory_order_acquire.<br /><br />- Relaxed operations obey a happens-before rule that can be used together with acquire-release operations...<br />&nbsp; // thread_1<br />&nbsp; x.store(123, std::memory_order_relaxed); // relaxed X happens-before Y store<br />&nbsp; y.store(true, std::memory_order_release);<br /><br />&nbsp; // thread_2<br />&nbsp; while(!y.load(std::memory_order_acquire));<br />&nbsp; assert(123 == x.load(std::memory_order_relaxed));<br />&nbsp; <br />&nbsp; The happens-before relationship guarantees that there will be no assert failure in assert(123 == x.load(relaxed)).<br /><br />&nbsp; Since the thread_1: x.store(123,relaxed) happens-before the y.store(true, release) <br />&nbsp; it is guaranteed that when thread_2: reads true == y.load(acquire) the value of x must already be 123.<br /><br />&nbsp;---------------------------------<br />http://en.cppreference.com/w/cpp/atomic/memory_order <br /><h4><span class="mw-headline" id="Release-Acquire_ordering">Release-Acquire ordering</span></h4><h4><span class="mw-headline" id="Release-Acquire_ordering">&nbsp;</span>Mutual exclusion locks (such as <span class="t-lc"><a href="http://en.cppreference.com/w/cpp/thread/mutex" title="cpp/thread/mutex">std::mutex</a></span> or <a href="http://en.cppreference.com/w/cpp/atomic/atomic_flag" title="cpp/atomic/atomic flag">atomic spinlock</a>)  are an example of release-acquire synchronization: when the lock is  released by thread A and acquired by thread B, everything that took  place in the critical section (before the release) in the context of  thread A has to be visible to thread B (after the acquire) which is  executing the same critical section. </h4>&nbsp; <br /><br />&nbsp;(*) Sequential Consistent<br />&nbsp; <br /><br />&nbsp;&nbsp;&nbsp; A sequential consistent store will be synchronized with a sequential consistent load of the same data. <br />&nbsp;&nbsp;&nbsp; It is guaranteed thanks to a global synchronization between involved threads.<br /><br />&nbsp;&nbsp;&nbsp; All threads participating in these sequential atomic operations will see exactly the same order of the operations.<br /><br />&nbsp;&nbsp;&nbsp; Atomic operations within the same thread cannot be reordered.<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; A seqence of atomic operations in one thread will have the same sequence of order seen by other threads<br /><br />