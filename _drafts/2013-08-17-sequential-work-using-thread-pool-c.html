---
layout: post
title: sequential work using thread pool (c++, pthread)
date: '2013-08-17T16:50:00.008+09:00'
author: jeremyko
tags:
- c++
modified_time: '2020-05-22T15:07:57.276+09:00'
thumbnail: https://1.bp.blogspot.com/-6wH9x0YqNXs/Ug8f9tCATsI/AAAAAAAADxg/ZSDg4lmqzUA/s72-c/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA+2013-08-17+%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE+3.56.51.png
blogger_id: tag:blogger.com,1999:blog-7360229670252766698.post-352721092849627180
blogger_orig_url: https://jeremyko.blogspot.com/2013/08/sequential-work-using-thread-pool-c.html
---

pthread pool 를 기반으로 구현된 순차적 출력 처리 클래스.<br /><br />이를 사용하면 어떤 작업들을 병렬로 처리 후 그 결과들을 사용하는데 있어서 특정한 순서가 요구될 때 이용 될 수 있다.(계속되는 입력데이터를 처리하는 일종의 fork-join parallel pattern)<br /><br /><span style="color: #990000;">thread pool 내에서 동작하는 작업 쓰레드들간의 처리 순서를 제어한다는 의미는 아님. 특정 작업은 병렬로 처리 가능해야 하고 그결과를 순차적으로 사용하는 경우를 의미. </span><br /><br />예를 들어, 전달된 데이터를 가지고 시간이 걸리는 복잡한 계산을 수행후, 그 결과를 전달된 순서대로 파일에 쓰는 경우를 가정해보자.<br /><br />단순히 thread pool에 작업들을 전달하면, 순서없이 먼저 처리되는 작업이 파일에 먼저 저장될것이다. 이를 해결하기 위해서는 thread pool + 추가적인 코딩이 필요한데, 이것이 하나의 클래스로 구현되어 있다.<br /><br />스레드풀 순차적 처리 관리자 라고 명명한 이 클래스는 내부적으로 thread pool의 작업 쓰레드가 완료될때 해당 처리된 데이터들을 관리하면서, 사용자가 관리자에게 요청된 순서대로 결과를 돌려주게 끔(콜백) 동작한다. <br /><br /><br /><a name='more'></a><br /><br />간단하게 예제로 만든 사용 방법은 다음과 같다.<br /><br /><!--HTML generated using hilite.me--><br /><div style="background: rgb(248, 248, 248) none repeat scroll 0% 0%; border: medium solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 100%; margin: 0px;">1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39<br />40<br />41<br />42<br />43<br />44<br />45<br />46<br />47<br />48<br />49<br />50<br />51<br />52<br />53<br />54<br />55<br />56<br />57<br />58<br />59<br />60<br />61<br />62<br />63<br />64<br />65<br />66<br />67<br />68<br />69<br />70<br />71<br />72<br />73<br />74<br />75<br />76<br />77<br />78<br />79<br />80<br />81<br />82<br />83<br />84<br />85<br />86<br />87<br />88</pre></td><td><pre style="line-height: 100%; margin: 0px;"><span style="color: #bc7a00;">#include &lt;iostream&gt;</span><br /><span style="color: #bc7a00;">#include &lt;string&gt;</span><br /><span style="color: #bc7a00;">#include &lt;sstream&gt;</span><br /> <br /><span style="color: #bc7a00;">#include "seq_thread_pool.hpp"</span><br /><br /><span style="color: #408080; font-style: italic;">//스레드 풀에서 수행되는 작업에 필요한 사용자 데이터 정의</span><br /><span style="color: green; font-weight: bold;">typedef</span> <span style="color: green; font-weight: bold;">struct</span> _ST_USER_WORK_DATA<br />{<br />    <span style="color: #b00040;">int</span> n_work_time;<br />    string work_data;<br />} ST_USER_WORK_DATA ;<br /><br /><br /><span style="color: #408080; font-style: italic;">//스레드풀에서 처리될 스레드 함수를 정의한다. 즉, 사용자가 수행할 작업을 의미.</span><br /><span style="color: #b00040;">void</span> <span style="color: blue;">MyThreadProc</span>(<span style="color: #b00040;">void</span><span style="color: #666666;">*</span> arg) <br />{        <br />    ST_USER_WORK_DATA<span style="color: #666666;">*</span> pUserData <span style="color: #666666;">=</span> (ST_USER_WORK_DATA<span style="color: #666666;">*</span>)arg;<br /><br />    <span style="color: #408080; font-style: italic;">//전달된 데이터를 가지고 작업을 수행한다.</span><br />    <span style="color: #408080; font-style: italic;">//여기서는 작업부하를 usleep 호출로 시뮬레이트한다.</span><br /><br />    pUserData<span style="color: #666666;">-&gt;</span>work_data <span style="color: #666666;">=</span> pUserData<span style="color: #666666;">-&gt;</span>work_data <span style="color: #666666;">+</span> <span style="color: #ba2121;">" : done"</span><br /><br />    usleep( pUserData<span style="color: #666666;">-&gt;</span>n_work_time ); <br />}<br /><br /><span style="color: #408080; font-style: italic;">//스레드 풀에서 처리된 최종 결과가 전달되는 함수를 정의한다.</span><br /><span style="color: #408080; font-style: italic;">//이함수는 스레드풀 순차적 처리 관리자에게 요청한 순서대로 순차적으로 호출된다.</span><br /><span style="color: #b00040;">void</span> <span style="color: blue;">WorkDoneCallBack</span> (<span style="color: #b00040;">int</span> nSeq, <span style="color: #b00040;">void</span><span style="color: #666666;">*</span> data)<br />{<br />    ST_USER_WORK_DATA<span style="color: #666666;">*</span> pData <span style="color: #666666;">=</span> (ST_USER_WORK_DATA<span style="color: #666666;">*</span>)data;<br />    cout <span style="color: #666666;">&lt;&lt;</span> <span style="color: #ba2121;">"/"</span> <span style="color: #666666;">&lt;&lt;</span> pData<span style="color: #666666;">-&gt;</span>work_data <span style="color: #666666;">&lt;&lt;</span> <span style="color: #ba2121;">"</span><span style="color: #bb6622; font-weight: bold;">\n</span><span style="color: #ba2121;">"</span>;<br /><br />    <span style="color: green; font-weight: bold;">delete</span> pData; <span style="color: #408080; font-style: italic;">//최종적으로 사용이 끝난 작업 데이터를 삭제.</span><br />    pData <span style="color: #666666;">=</span> <span style="color: green;">NULL</span>;<br />}<br /><br /><span style="color: #408080; font-style: italic;">//사용자의 호출 부분</span><br /><span style="color: #b00040;">int</span> <span style="color: blue;">main</span>()<br />{<br />    <span style="color: #408080; font-style: italic;">//스레드풀 순차적 처리 관리자 객체를 선언.</span><br />    SeqentialWorkManager<span style="color: #666666;">*</span> pSeqManager <span style="color: #666666;">=</span> <span style="color: green; font-weight: bold;">new</span> SeqentialWorkManager ();<br /><br />    <span style="color: green; font-weight: bold;">if</span>( <span style="color: #666666;">!</span> pSeqManager<span style="color: #666666;">-&gt;</span>Init() ) <span style="color: #408080; font-style: italic;">//초기화</span><br />    {<br />        cout <span style="color: #666666;">&lt;&lt;</span> <span style="color: #ba2121;">"Error : Init"</span> <span style="color: #666666;">&lt;&lt;</span> <span style="color: #ba2121;">"</span><span style="color: #bb6622; font-weight: bold;">\n</span><span style="color: #ba2121;">"</span>;<br />        <span style="color: green; font-weight: bold;">return</span> <span style="color: #666666;">-1</span>;<br />    }<br /><br />    ostringstream variable;<br />    variable <span style="color: #666666;">&lt;&lt;</span> <span style="color: #666666;">1</span> ; <br /><br />    <span style="color: #408080; font-style: italic;">//전달할 작업 데이터를 준비한다</span><br />    ST_USER_WORK_DATA<span style="color: #666666;">*</span> pData1 <span style="color: #666666;">=</span> <span style="color: green; font-weight: bold;">new</span> ST_USER_WORK_DATA;<br />    pData1<span style="color: #666666;">-&gt;</span>work_data <span style="color: #666666;">=</span> variable.str(); <span style="color: #408080; font-style: italic;">//data</span><br />    pData1<span style="color: #666666;">-&gt;</span>n_work_time <span style="color: #666666;">=</span> <span style="color: #666666;">1000</span>; <br />    <br />    pSeqManager<span style="color: #666666;">-&gt;</span>AssignWork( MyThreadProc, pData1, <span style="color: green; font-weight: bold;">sizeof</span>(ST_USER_WORK_DATA),  <br />        WorkDoneCallBack );<br /><br />    variable.seekp(<span style="color: #666666;">0</span>);<br />    variable <span style="color: #666666;">&lt;&lt;</span> <span style="color: #666666;">2</span> ; <br />    ST_USER_WORK_DATA<span style="color: #666666;">*</span> pData2 <span style="color: #666666;">=</span> <span style="color: green; font-weight: bold;">new</span> ST_USER_WORK_DATA;<br />    pData2<span style="color: #666666;">-&gt;</span>work_data <span style="color: #666666;">=</span> variable.str(); <span style="color: #408080; font-style: italic;">//data</span><br />    pData2<span style="color: #666666;">-&gt;</span>n_work_time <span style="color: #666666;">=</span> <span style="color: #666666;">100</span>; <br />    <br />    pSeqManager<span style="color: #666666;">-&gt;</span>AssignWork( MyThreadProc, pData2, <span style="color: green; font-weight: bold;">sizeof</span>(ST_USER_WORK_DATA),  <br />        WorkDoneCallBack );<br /><br />    variable.seekp(<span style="color: #666666;">0</span>);<br />    variable <span style="color: #666666;">&lt;&lt;</span> <span style="color: #666666;">3</span> ; <br />    ST_USER_WORK_DATA<span style="color: #666666;">*</span> pData3 <span style="color: #666666;">=</span> <span style="color: green; font-weight: bold;">new</span> ST_USER_WORK_DATA;<br />    pData3<span style="color: #666666;">-&gt;</span>work_data <span style="color: #666666;">=</span> variable.str(); <span style="color: #408080; font-style: italic;">//data</span><br />    pData3<span style="color: #666666;">-&gt;</span>n_work_time <span style="color: #666666;">=</span> <span style="color: #666666;">10</span>; <br />    <br />    pSeqManager<span style="color: #666666;">-&gt;</span>AssignWork( MyThreadProc, pData3, <span style="color: green; font-weight: bold;">sizeof</span>(ST_USER_WORK_DATA),  <br />        WorkDoneCallBack );<br /><br />    pSeqManager<span style="color: #666666;">-&gt;</span>Terminate();<br />    <span style="color: green; font-weight: bold;">delete</span> pSeqManager;<br />    <span style="color: green; font-weight: bold;">return</span> <span style="color: #666666;">0</span>;<br />}<br /><br /><span style="color: #408080; font-style: italic;">/*</span><br /><span style="color: #408080; font-style: italic;">* 결과</span><br /><span style="color: #408080; font-style: italic;">cpu count: 8</span><br /><span style="color: #408080; font-style: italic;">/1 : done</span><br /><span style="color: #408080; font-style: italic;">/2 : done</span><br /><span style="color: #408080; font-style: italic;">/3 : done</span><br /><span style="color: #408080; font-style: italic;">*/</span><br /></pre></td></tr></tbody></table></div><div class="post-body entry-content" id="post-body-352721092849627180" itemprop="description articleBody" style="-webkit-text-stroke-width: 0px; background-color: #fefdfa; color: #333333; font-family: &quot;arial&quot;, &quot;tahoma&quot;, &quot;helvetica&quot;, &quot;freesans&quot;, sans-serif; font-size: 13px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 18px; position: relative; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; width: 636px; word-spacing: 0px;"><br /><pre class="sunburst" style="background-color: white; font-family: &quot;bitstream vera sans mono&quot;, &quot;inconsolata&quot;, &quot;monaco&quot;, &quot;consolas&quot;, &quot;courier new&quot;, monospace; font-size: 10px; line-height: 13px; margin-top: 0em;"></pre><br /><span style="background-color: #fefdfa; color: #333333; font-family: &quot;arial&quot;, &quot;tahoma&quot;, &quot;helvetica&quot;, &quot;freesans&quot;, sans-serif; font-size: 13px; line-height: 18px;"></span><br /><br />이 예에서 작업데이터의 처리 완료가 3,2,1 순서로 되게 끔 작업시간을 임의로 지정했지만, 순차적 처리 관리자 클래스에 의해 1,2,3 처럼 순차적으로 완료됨을 알수있다.<br /><br />한편 이런 방식의 처리가 적합한 경우를 판단하기 위해서는 다음 몇가지 고려사항이 존재한다.<br /><br />- 전체 core(cpu) 갯수<br />- 쓰레드로 처리하는 개별작업에  얼마만큼 시간이 소요되는지.<br />- 전체 처리 건수는 몇건인지.<br /><br />이 값들이 클수록 thread 풀을 활용한 순차실행은 , 하나의 쓰레드를 이용한 작업보다 성능상의 큰 향상을 가져올수 있다. <br /><br />반면, 순차실행으로도 충분히 빠른 결과를 얻을수 있는경우 (즉, 처리건수가 얼마 안되고 개별 작업의 처리시간이 작은경우) 에는 오히려 쓰레드 풀 사용이 유리하지는 않으므로, 실험을 통해서 적합 여부를 판단해야 한다.<br /><br />그럼 좀더 대량의 데이터를 가지고 테스트 (링크된 소스중 testApp.cpp코드) 해 보자. 다음은 맥북프로 Mid 2012, intel core i7 core 4 개인 환경에서 테스트해본 결과이다.<br /><br />먼저 테스트 프로그램이 하는 일은, 할일의 갯수 즉 CNT_TEST가 지정되고, 일하는데 걸리는 시간이 WORK_TIME_SHORT, WORK_TIME_LONG (마이크로 초)으로 주어진다. <br /><br />그리고 프로그램은 0 부터 CNT_TEST 만큼 순차적으로 작업 인덱스를 부여하게 되며, 각각의 작업 완료시 자신의 인덱스를 출력한다. <br /><br />비교를 위해서 단일 루프로 처리하는 로직과 쓰레드 풀을 이용한 순차처리 방식으로 테스트 해보았다. <br /><br />먼저 개별 작업들이 짧은 시간안에 완료되는 경우를 가정해본다.<br />각각 10, 30 마이크로초 걸리는 작업들이 번갈아 수행되는 경우이고 총 작업량은 600번이다.<br /><br /><div class="separator" style="background-color: #fefdfa; clear: both; color: #333333; font-family: &quot;arial&quot;, &quot;tahoma&quot;, &quot;helvetica&quot;, &quot;freesans&quot;, sans-serif; font-size: 13px; line-height: 18px; text-align: center;"><a href="http://1.bp.blogspot.com/-6wH9x0YqNXs/Ug8f9tCATsI/AAAAAAAADxg/ZSDg4lmqzUA/s1600/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA+2013-08-17+%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE+3.56.51.png" style="color: #7d181e; margin-left: 1em; margin-right: 1em; text-decoration: none;"><img border="0" height="298" src="https://1.bp.blogspot.com/-6wH9x0YqNXs/Ug8f9tCATsI/AAAAAAAADxg/ZSDg4lmqzUA/s1600/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA+2013-08-17+%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE+3.56.51.png" style="background-color: white; border-radius: 5px; border: 1px solid rgb(204, 204, 204); box-shadow: rgba(0, 0, 0, 0.2) 0px 0px 20px; padding: 8px; position: relative;" width="320" /></a></div><br style="background-color: #fefdfa; color: #333333; font-family: &quot;arial&quot;, &quot;tahoma&quot;, &quot;helvetica&quot;, &quot;freesans&quot;, sans-serif; font-size: 13px; line-height: 18px;" /><br /><br /><br /><br />쓰레드 풀을 적용한 결과도 순차적으로 결과가 출력됨을 알수있다.<br /><br />그런데 쓰레드풀을 이용한 순차처리가 오히려 느리다. 즉, 개별 작업 수행이 상당히 빠른 경우엔 쓰레드 풀 방식이 적합하지 않아 보인다. 그런데 여기서 고려할 변수가 있는데 전체 처리 건수와 코어갯수 이다. <br /><br />만약 전체 처리 건수가 아주 많은 경우, 그리고 코어수가 지금 테스트 장비보다 많은 경우라면 다른 결과를 보일수도 있다. 이것은 실험에 의해 판단할수 밖에 없다.&nbsp;</div><div class="post-body entry-content" id="post-body-352721092849627180" itemprop="description articleBody" style="-webkit-text-stroke-width: 0px; background-color: #fefdfa; color: #333333; font-family: &quot;arial&quot;, &quot;tahoma&quot;, &quot;helvetica&quot;, &quot;freesans&quot;, sans-serif; font-size: 13px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 18px; position: relative; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; width: 636px; word-spacing: 0px;"><br />그래서 core 24개인 리눅스 서버에서 동일한 조건으로 테스트 해보았다.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-grdZhD33QDc/UhGisMWqsxI/AAAAAAAADyQ/jLNFZI7PbL8/s1600/tpool_core24.PNG" style="color: #7d181e; margin-left: 1em; margin-right: 1em; text-decoration: none;"><img border="0" height="212" src="https://2.bp.blogspot.com/-grdZhD33QDc/UhGisMWqsxI/AAAAAAAADyQ/jLNFZI7PbL8/s1600/tpool_core24.PNG" style="background-color: white; border-radius: 5px; border: 1px solid rgb(204, 204, 204); box-shadow: rgba(0, 0, 0, 0.2) 0px 0px 20px; padding: 8px; position: relative;" width="320" /></a></div><span style="color: #333333; font-family: &quot;arial&quot;, &quot;tahoma&quot;, &quot;helvetica&quot;, &quot;freesans&quot;, sans-serif; font-size: xx-small;"><span style="line-height: 18px;"><br /></span></span>동일한 조건이지만 이번에는 스레드풀 사용이 월등히 빠른것으로 나온다.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-Fvs-tiEsdXg/UhHiH1L5iTI/AAAAAAAADyg/WuG7jbpemwc/s1600/2.PNG" style="color: #7d181e; margin-left: 1em; margin-right: 1em; text-decoration: none;"><img border="0" height="186" src="https://2.bp.blogspot.com/-Fvs-tiEsdXg/UhHiH1L5iTI/AAAAAAAADyg/WuG7jbpemwc/s1600/2.PNG" style="background-color: white; border-radius: 5px; border: 1px solid rgb(204, 204, 204); box-shadow: rgba(0, 0, 0, 0.2) 0px 0px 20px; padding: 8px; position: relative;" width="320" /></a></div><span style="background-color: #fefdfa; color: #333333; font-family: &quot;arial&quot;, &quot;tahoma&quot;, &quot;helvetica&quot;, &quot;freesans&quot;, sans-serif; font-size: 13px; line-height: 18px;"></span><br /><br />다른 조건을 주고 한번 더 테스트 해보니 22배 차이가 나고 있다.<br />이번엔 다시 core 4 조건에서 작업 처리시간을 좀더 늘려보았다.<br /><br />30 -&gt; 300 마이크로초 로 증가 한후 수행한 결과이다.<br /><br /><div class="separator" style="background-color: #fefdfa; clear: both; color: #333333; font-family: &quot;arial&quot;, &quot;tahoma&quot;, &quot;helvetica&quot;, &quot;freesans&quot;, sans-serif; font-size: 13px; line-height: 18px; text-align: center;"><a href="http://2.bp.blogspot.com/-1ydkzpfP_-M/Ug8gAKgPfiI/AAAAAAAADxw/lh91JbPVEQQ/s1600/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA+2013-08-17+%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE+3.58.45.png" style="color: #7d181e; margin-left: 1em; margin-right: 1em; text-decoration: none;"><img border="0" height="48" src="https://2.bp.blogspot.com/-1ydkzpfP_-M/Ug8gAKgPfiI/AAAAAAAADxw/lh91JbPVEQQ/s1600/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA+2013-08-17+%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE+3.58.45.png" style="background-color: white; border-radius: 5px; border: 1px solid rgb(204, 204, 204); box-shadow: rgba(0, 0, 0, 0.2) 0px 0px 20px; padding: 8px; position: relative;" width="320" /></a></div><br /><br />이번에는 쓰레드 풀을 이용한 성능 향상이 확인 되었다. 약 7.6 배.</div><div class="post-body entry-content" id="post-body-352721092849627180" itemprop="description articleBody" style="-webkit-text-stroke-width: 0px; background-color: #fefdfa; color: #333333; font-family: &quot;arial&quot;, &quot;tahoma&quot;, &quot;helvetica&quot;, &quot;freesans&quot;, sans-serif; font-size: 13px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 18px; position: relative; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; width: 636px; word-spacing: 0px;">다음은 수행 횟수를 10만번으로 증가시켜 수행해보았다.</div><div class="post-body entry-content" id="post-body-352721092849627180" itemprop="description articleBody" style="-webkit-text-stroke-width: 0px; background-color: #fefdfa; color: #333333; font-family: &quot;arial&quot;, &quot;tahoma&quot;, &quot;helvetica&quot;, &quot;freesans&quot;, sans-serif; font-size: 13px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 18px; position: relative; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; width: 636px; word-spacing: 0px;"><div class="separator" style="background-color: #fefdfa; clear: both; color: #333333; font-family: &quot;arial&quot;, &quot;tahoma&quot;, &quot;helvetica&quot;, &quot;freesans&quot;, sans-serif; font-size: 13px; line-height: 18px; text-align: center;"><a href="http://2.bp.blogspot.com/-Fo24SL7NMWA/Ug8gAJNlUMI/AAAAAAAADx8/l2wVObjmV_E/s1600/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA+2013-08-17+%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE+3.59.42.png" style="color: #7d181e; margin-left: 1em; margin-right: 1em; text-decoration: none;"><img border="0" height="51" src="https://2.bp.blogspot.com/-Fo24SL7NMWA/Ug8gAJNlUMI/AAAAAAAADx8/l2wVObjmV_E/s1600/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA+2013-08-17+%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE+3.59.42.png" style="background-color: white; border-radius: 5px; border: 1px solid rgb(204, 204, 204); box-shadow: rgba(0, 0, 0, 0.2) 0px 0px 20px; padding: 8px; position: relative;" width="320" /></a></div><br style="background-color: #fefdfa; color: #333333; font-family: &quot;arial&quot;, &quot;tahoma&quot;, &quot;helvetica&quot;, &quot;freesans&quot;, sans-serif; font-size: 13px; line-height: 18px;" /><br /><br />약 8.2배 성능 향상이 있다. 이런 수치들은 그냥 참고만 할 정보들일것이고, 실제 이 코드를 적용하는 상황에서 다시 성능상의 이슈를 점검해봐야 할것이다. <br /><br />전체 소스는 다음을 참고.<span style="background-color: #fefdfa; color: #333333; font-family: &quot;arial&quot;, &quot;tahoma&quot;, &quot;helvetica&quot;, &quot;freesans&quot;, sans-serif; font-size: 13px; line-height: 18px;"><br /></span><a href="https://github.com/jeremyko/sequential_write_using_thread_pool" style="background-color: #fefdfa; color: #7d181e; font-family: Arial, Tahoma, Helvetica, FreeSans, sans-serif; font-size: 13px; line-height: 18px; text-decoration: none;"><b>https://github.com/jeremyko/sequential_write_using_thread_pool</b></a><br /><div style="clear: both;"></div></div>