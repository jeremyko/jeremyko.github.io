---
layout: post
title: Effective Modern C++ study
date: '2015-09-16T21:30:00.000+09:00'
author: jeremyko
tags:
- Effective Modern C++
- study
modified_time: '2015-09-16T21:30:17.482+09:00'
blogger_id: tag:blogger.com,1999:blog-7360229670252766698.post-8190460529380305233
blogger_orig_url: https://jeremyko.blogspot.com/2015/09/effective-modern-c-study.html
---

<span style="font-family: Verdana,sans-serif;"><b>제목 및 초간단 요약으로 정리 </b></span><br /><br /><span style="background-color: #fff2cc;"><span style="font-family: Verdana,sans-serif;"><b>Item 35</b></span></span><br /><span style="background-color: #fff2cc;"><span style="font-family: Verdana,sans-serif;">Prefer task-based programming to thread-based</span></span><br /><br /><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">쓰레드 기반 대신 태스크 기반 프로그래밍을 고려하자.</span></span><br /><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">가급적 std::thread&nbsp; 대신 std::async 을 사용하자. std::async 를 사용한 태스크 기반&nbsp;</span></span><br /><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">프로그래밍은 thread 고갈, hardware thread 초과하는 software thread 사용, 부하 분산,&nbsp;</span></span><br /><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">새로운 플랫폼에 적용하는 문제등을 대신 처리해준다 (물론 thread 사용이 정말 필요한 경우는 예외이다).</span></span><br /><br /><span style="background-color: #fff2cc;"><span style="font-family: Verdana,sans-serif;"><b>Item 36</b></span></span><br /><span style="background-color: #fff2cc;"><span style="font-family: Verdana,sans-serif;">Specify std::launch::async if asynchronicity is essential</span></span><br /><br /><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">비동시성이 필수조건이라면 std::async 호출 시 std::launch::async 정책을 지정하자.<br />정책없이 std::async 호출 한다면 사용자 함수가 어떻게(동기식, 비동기식), 언제 수행될지는 OS 가 판단한다. 즉 std::launch::async , std::launch::deferred 2가지 정책 중에서 OS가 적절한것을 선택한다.만약 std::launch::deferred 정책이 수행된다면 사용자 함수안에서 반드시 함수가 종료된다고 해도 wait_for 로 대기하면 무한루프에 빠진다.&nbsp;&nbsp;</span></span><br /><br /><span style="background-color: #fff2cc;"><span style="font-family: Verdana,sans-serif;"><b>Item 37</b></span></span><br /><span style="background-color: #fff2cc;"><span style="font-family: Verdana,sans-serif;">Make std::threads unjoinable on all paths</span></span><br /><br /><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">thread 시작후에 join() 호출없이 소멸자가 호출된다면(joinable상태로) application실행이 멈춘다. 소멸자안에 join, detach 를 호출하지 않은것은 다 이유가 있다. 모든 실행 경로에 쓰레드가 정상 종료되게끔 처리. RAII 를 활용. 클래스 멤버 초기화 리스트는 멤버 선언 순서를 따르므로 thread멤버는 클래스 가장 마지막에 선언하는 것이 좋은 습관. </span></span><br /><br /><span style="background-color: #fff2cc;"><span style="font-family: Verdana,sans-serif;"><b>Item 38</b></span></span><br /><span style="background-color: #fff2cc;"><span style="font-family: Verdana,sans-serif;">Be aware of varying thread handle destructor behavior</span></span><br /><br /><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">std::future가 일반적인 사용이 아닌 경우에 특수한 행동을 보이는 경우를 유의하자. </span></span><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">여기서 일반적이지 않은 상황이란 1.std::async호출로 shared state를 참조하게 된 경우, 2. task launch policy 가 std::launch::async 이거나 </span></span><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">std::async호출시 그것으로 설정된 경우, 3.</span></span> future가 </span></span><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">shared state 를 참조하는 마지막 객체인 경우 모두 해당되는 경우를 말한다. </span></span></span></span>std::thread와 달리 </span></span><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">소멸자안에서 마치 join, detach 를 호출하는것처럼 행동하는 이유. future 사용시 callee’s result 는 shared state에 저장된다. </span></span><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">shared state 를 참조하는 마지막 </span></span>future 객체의 소멸자에서는 task 완료될때까지 block된다(마치 thread join을 호출하는 것처럼). 그외의 future 객체 소멸자에서는 간단하게 객체만 삭제한다(마치 thread detach호출처럼).&nbsp;</span></span><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"></span></span></span></span><br /><br /><span style="background-color: #fff2cc;"><span style="font-family: Verdana,sans-serif;"><b>Item 39</b></span></span><br /><span style="background-color: #fff2cc;"><span style="font-family: Verdana,sans-serif;">Consider void futures for one-shot event communication</span></span><br /><br /><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">ㄹㅇㄴㅁㄻㄴ출 시 s</span></span><br /><br /><span style="background-color: #fff2cc;"><span style="font-family: Verdana,sans-serif;"><b>Item40</b></span></span><br /><span style="background-color: #fff2cc;"><span style="font-family: Verdana,sans-serif;">Use&nbsp; std::atomic for concurrency,&nbsp; volatile for special memory</span></span><br /><br /><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">volatiile 과 동시성은 상관없다.&nbsp; 용도에 맞게 사용하자.</span></span><br /><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">volatile : RMW 뿐만 아니라 code re-ordering&nbsp; 문제도 존재.</span></span><br /><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">메모리 read, write이 최적화 되지 않아야 하는 special memory 를 다루기 위해 필요하다. </span></span></span></span><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">volatile 키워드는 컴파일러에게 지금 </span></span></span></span></span></span></span></span><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">special memory 를 다루고 있음을 알려주기 위한 용도이다. </span></span></span></span>그 대표적인 예는 memory-mapped I/O. atomic만 가지고는 컴파일러의 최적화 처리로 인해 문제가 발생할수 있다.&nbsp;</span></span></span></span><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;">여러 쓰레드에서 </span></span></span><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;">memory-mapped I/O 가 필요한 경우</span></span></span></span>라면 volatile 과 atomic 을 같이 사용할수도 있다(volatile std::atomic&lt;int&gt; vai 처럼). </span></span></span></span><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"></span></span></span></span><br /><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><br /></span></span></span></span><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><span style="font-family: Verdana,sans-serif;"><span style="color: #0b5394;"><br /></span></span></span></span>