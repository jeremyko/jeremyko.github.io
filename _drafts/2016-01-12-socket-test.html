---
layout: post
title: socket test
date: '2016-01-12T21:41:00.000+09:00'
author: jeremyko
tags:
modified_time: '2016-01-12T21:41:12.540+09:00'
blogger_id: tag:blogger.com,1999:blog-7360229670252766698.post-1098636760877799621
blogger_orig_url: https://jeremyko.blogspot.com/2016/01/socket-test.html
---

http://pastie.org/10681247<br /><br /><a href="http://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html" target="_blank">http://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html</a><br /><br />This means that current Linux versions use the second option with <span style="background-color: #d9ead3;">two distinct queues: a <b>SYN queue</b> with a size specified by a <b><i>system wide setting</i></b> </span>and an <span style="background-color: yellow;"><b>accept queue</b> with a size specified by the <b>application</b></span>.<br /><br />The interesting question is now how such an implementation behaves if the accept queue is full and a connection needs to be moved from the SYN queue to the accept queue, i.e. when the ACK packet of the 3-way handshake is received. This case is handled by the tcp_check_req function in net/ipv4/tcp_minisocks.c. The relevant code reads:<br /><br />This means that unless /proc/sys/net/ipv4/tcp_abort_on_overflow is set to 1 (in which case the code right after the code shown above will <span style="background-color: yellow;">send a RST packet</span>), the implementation <span style="background-color: yellow;">basically does… nothing!</span><br />To summarize, <span style="background-color: #d0e0e3;">if the TCP implementation in Linux receives the ACK packet of the 3-way handshake and the accept queue is full, it will basically <b>ignore</b> that packet</span>. At first, this sounds strange, but remember that there is a timer associated with the SYN RECEIVED state: if the ACK packet is not received (or if it is ignored, as in the case considered here), then the TCP implementation will resend the SYN/ACK packet (with a certain number of retries specified by /proc/sys/net/ipv4/tcp_synack_retries and using an exponential backoff algorithm).<br /><br />The packet trace also shows another interesting aspect of this behavior. <span style="background-color: yellow;">From the point of view of the client, the connection will be in state ESTABLISHED after reception of the first SYN/ACK. If it sends data (without waiting for data from the server first), then that data will be retransmitted as well</span>. Fortunately <a href="http://en.wikipedia.org/wiki/Slow-start">TCP slow-start</a>should limit the number of segments sent during this phase.<br /><br />On the other hand, <span style="background-color: yellow;">if the client first waits for data from the server and the server never reduces the backlog, then the end result is that on the client side, the connection is in state ESTABLISHED, while on the server side, the connection is considered CLOSED</span>. This means that we end up with a <a href="http://en.wikipedia.org/wiki/Half-open_connection">half-open connection</a>!<br /><br /><br />cat /proc/sys/net/ipv4/tcp_syncookies<br />cat /proc/sys/net/ipv4/tcp_max_syn_backlog<br />cat /proc/sys/net/ipv4/tcp_abort_on_overflow<br />cat /proc/sys/net/ipv4/tcp_synack_retries<br /><span style="color: green;">cat /proc/sys/net/core/somaxconn&nbsp; </span><br /><br /><br /><br /><br /><a href="https://voipmagazine.wordpress.com/tag/tcp_max_syn_backlog/" target="_blank">https://voipmagazine.wordpress.com/tag/tcp_max_syn_backlog/</a><br /><br /><ul><li style="text-align: justify;">Tune the value of “backlog” (<b>maximum queue length of pending connections </b>“Waiting Acknowledgment”):</li></ul><div style="padding-left: 60px;"><span style="color: green;">tcp_max_syn_backlog= 300000 </span></div><ul><li>Set the value of <i>somaxconn</i>. This is the Max value of the backlog. The default value is 128. If the <i>backlog</i> is greater than somaxconn, it will truncated to it.</li></ul><div style="padding-left: 60px;"><span style="color: #333333;">Temporarily</span>:&nbsp; <span style="color: green;"># echo&nbsp;300000 &gt; /proc/sys/net/core/somaxconn </span></div><div style="padding-left: 60px;"><span style="color: green;"><span style="color: #333333;">Permanently</span>: <span style="color: #333333;">Add the line</span>: <span class="skimlinks-unlinked">net.core.somaxconn</span>=&nbsp;300000 in<span style="color: #333333;"> the file /etc/<span class="skimlinks-unlinked">sysctl.conf</span>. Reload the change (# sysctl -p). </span></span></div><ul><li style="text-align: justify;">” TIME_WAIT” TCP socket state is the  state where the socket is closed but waiting to handle the packets which  are still in the network. The parameter tcp_max_tw_buckets is the  maximum number of sockets in “TIME_WAIT” state. After reaching this  number the system will start destroying the socket in this state. To get  the default value:</li></ul><div style="padding-left: 60px;"># cat /proc/sys/net/ipv4/tcp_max_tw_buckets.</div><div style="padding-left: 30px;">Increase the value to 2000000 (2 million). Increasing this value leads to requirement of more memory.</div><div style="padding-left: 60px;">Temporarily:</div><div style="padding-left: 90px;"># echo 2000000 &gt; /proc/sys/net/ipv4/tcp_max_tw_buckets</div><div style="padding-left: 60px;">Permanently: <span style="color: green;"><span style="color: #333333;">Add the line</span>: <span class="skimlinks-unlinked">net.ipv4.tcp_max_tw_buckets</span>=&nbsp;2000000 <span style="color: #333333;">in the file /etc/<span class="skimlinks-unlinked">sysctl.conf</span>. Reload the change (<span style="color: green;"># sysctl -p</span>). </span></span></div><br /><br /><br /><br /><a href="http://stackoverflow.com/questions/18122498/listen-backlog-upper-limits" target="_blank">http://stackoverflow.com/questions/18122498/listen-backlog-upper-limits</a><br /><br /><div class="post-text" itemprop="text"><span style="background-color: yellow;"><b><code>somaxconn</code></b> is the number of <i>complete</i> connections waiting.</span><br /><span style="background-color: yellow;"> </span><span style="background-color: yellow;"><b><code>tcp_max_syn_backlog</code></b> is the number of <i>incomplete</i> connections waiting.</span><br /><span style="background-color: yellow;"> </span><span style="background-color: yellow;">They aren't the same thing. It's all described in the <a href="http://linux.die.net/man/2/listen" rel="nofollow"><i>man page</i></a>.</span><br /><br /></div>The behavior of the <i>backlog</i> argument on TCP sockets changed with Linux 2.2. Now it specifies the queue length for <b><i>completely</i> established</b>sockets waiting to be accepted, instead of the number of incomplete  connection requests. The maximum length of the queue for <b>incomplete  sockets</b> can be set using <b><i>/proc/sys/net/ipv4/tcp_max_syn_backlog</i></b>. When <b>syncookies are enabled there is no logical maximum length and this setting is ignored</b>. See <i><b><a href="http://linux.die.net/man/7/tcp">tcp</a></b>(7)</i> for more information. <br />If the <i>backlog</i> argument is greater than the value in <i>/proc/sys/net/core/somaxconn</i>, then it is silently truncated to that value; the default value in this file is 128. In kernels before 2.4.25, this limit was a hard coded value, <b>SOMAXCONN</b>, with the value 128. <br /><br /><br /><br />HP-UX는 linux 와 다르다 <br /><a href="http://nixdoc.net/man-pages/HP-UX/man2/listen.2.html" target="_blank">http://nixdoc.net/man-pages/HP-UX/man2/listen.2.html</a><br /><br />backlog is limited to the range of 0 to SOMAXCONN, which is defined in<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;sys/socket.h&gt;.&nbsp; SOMAXCONN is currently set to <span style="background-color: yellow;"><b>4096</b></span>.&nbsp; If any other<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value is specified, the system automatically assigns the closest value<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; within the range.&nbsp; A backlog of 0 specifies only 1 pending connection<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is allowed at any given time. <br /><br /><br /><br />** backlog 값이 10 인 경우, client thread 를 13개를 기동시킨 경우,<br /><br />kojh-mb-pro:socket_multithread_exemple kojunghyun$ ./LinClient 13<br />total thread =13<br />connected [1]!! elapsed: 0.000335<br />connected [2]!! elapsed: 0.000343<br />connected [3]!! elapsed: 0.000407<br />connected [4]!! elapsed: 0.001505<br />connected [5]!! elapsed: 0.001725<br />connected [6]!! elapsed: 0.001701<br />connected [7]!! elapsed: 0.001658<br />connected [8]!! elapsed: 0.001673<br />connected [9]!! elapsed: 0.001678<br />connected [10]!! elapsed: 0.001714<br />connected [11]!! elapsed: 0.001646<br />connected [12]!! elapsed: 0.001652<br />connected [13]!! elapsed: 0.001677 ---------&gt; connect 호출은 성공으로 리턴되지만 ....<br />Error receiving data Connection reset by peer ---&gt; 실제 데이터 수신에 실패한 경우가 발생됨...<br />Error receiving data Connection reset by peer<br />Error receiving data Connection reset by peer<br />----------- total test elapsed: 0.005542<br /><br />** 서버 로그 : 실제 연결은 10개 밖에 이루어지지 않았음...<br /><br />kojh-mb-pro:socket_multithread_exemple kojunghyun$ ./LinServer <br />max concurrent socket connection = 128<br />+++Received connection from 127.0.0.1 client cnt=0<br />+++Received connection from 127.0.0.1 client cnt=1<br />+++Received connection from 127.0.0.1 client cnt=2<br />+++Received connection from 127.0.0.1 client cnt=3<br />+++Received connection from 127.0.0.1 client cnt=4<br />+++Received connection from 127.0.0.1 client cnt=5<br />+++Received connection from 127.0.0.1 client cnt=6<br />+++Received connection from 127.0.0.1 client cnt=7<br />+++Received connection from 127.0.0.1 client cnt=8<br />+++Received connection from 127.0.0.1 client cnt=9<br /><br /><a href="http://stackoverflow.com/questions/19626527/mac-osx-10-9-listen-backlog-works-not-properly" target="_blank">http://stackoverflow.com/questions/19626527/mac-osx-10-9-listen-backlog-works-not-properly</a><br /><br />서버에서는 incompleted queue 저장 --&gt;client connect returns --&gt; connection established 상태가 되고, client에서는 이후에 데이터를 보내면 실패??<br /><br />usleep 을 준 경우엔 backlog 지정값 초과시 send가 호출안됨???<br />//os x <br />Note that before FreeBSD 4.5 and the introduction of the syncache, the backlog argument also determined the length of <br />the incomplete connection queue, which held TCP sockets in the process of completing TCP's 3-way handshake. <br />These incomplete connections are now held entirely in the syncache, which is unaffected by queue lengths. <br />Inflated backlog values to help handle denial of service attacks are no longer necessary.<br /><br /><br /><span style="color: red;">////////////////////////// SERVER ////////////////////////////</span><br />#include &lt;fcntl.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;errno.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;netinet/in.h&gt;<br />#include &lt;resolv.h&gt;<br />#include &lt;sys/socket.h&gt;<br />#include &lt;arpa/inet.h&gt;<br />#include &lt;unistd.h&gt;<br />#include &lt;pthread.h&gt;<br /><br />int nClientCnt = 0;<br />void* SocketHandler(void*);<br /><br />//-------------------------------------<br />int main(int argv, char** argc)<br />{<br />&nbsp;&nbsp;&nbsp; int host_port= 1101;<br /><br />&nbsp;&nbsp;&nbsp; struct sockaddr_in my_addr;<br /><br />&nbsp;&nbsp;&nbsp; int hsock;<br />&nbsp;&nbsp;&nbsp; int * p_int ;<br />&nbsp;&nbsp;&nbsp; socklen_t addr_size = 0;<br />&nbsp;&nbsp;&nbsp; sockaddr_in sadr;<br />&nbsp;&nbsp;&nbsp; pthread_t thread_id=0;<br /><br />&nbsp;&nbsp;&nbsp; hsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP );<br />&nbsp;&nbsp;&nbsp; if(hsock == -1){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("Error initializing socket %d\n", errno);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto FINISH;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; p_int = (int*)malloc(sizeof(int));<br />&nbsp;&nbsp;&nbsp; *p_int = 1;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; if( (setsockopt(hsock, SOL_SOCKET, SO_REUSEADDR, (char*)p_int, sizeof(int)) == -1 )||<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (setsockopt(hsock, SOL_SOCKET, SO_KEEPALIVE, (char*)p_int, sizeof(int)) == -1 ) )<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("Error setting options %d\n", errno);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; free(p_int);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto FINISH;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; free(p_int);<br /><br />&nbsp;&nbsp;&nbsp; my_addr.sin_family = AF_INET ;<br />&nbsp;&nbsp;&nbsp; my_addr.sin_port = htons(host_port);<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; char host_name[20];<br />&nbsp;&nbsp;&nbsp; snprintf(host_name, sizeof(host_name), "%s", "127.0.0.1");<br />&nbsp;&nbsp;&nbsp; memset(&amp;(my_addr.sin_zero), 0, 8);<br />&nbsp;&nbsp;&nbsp; //my_addr.sin_addr.s_addr = INADDR_ANY ;<br />&nbsp;&nbsp;&nbsp; my_addr.sin_addr.s_addr = inet_addr(host_name); ;<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; if( bind( hsock, (sockaddr*)&amp;my_addr, sizeof(my_addr)) == -1 )<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("Error binding to socket,&nbsp; %d\n",errno);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto FINISH;<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; printf("max concurrent socket connection = %d\n", SOMAXCONN ); <br /><br />&nbsp;&nbsp;&nbsp; //if(listen( hsock, 10) == -1 )<br />&nbsp;&nbsp;&nbsp; if(listen( hsock, SOMAXCONN ) == -1 ) //20150109 XXX TODO <br />&nbsp;&nbsp;&nbsp; //if(listen( hsock, 200 ) == -1 ) //20150109 XXX TODO <br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf( "Error listening %d\n",errno);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto FINISH;<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; addr_size = sizeof(sockaddr_in);<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; while(true)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int* csock;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //printf("waiting for a connection\n");<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; csock = (int*)malloc(sizeof(int));<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if((*csock = accept( hsock, (sockaddr*)&amp;sadr, &amp;addr_size))!= -1)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //printf("---------------------\nReceived connection from %s\n",inet_ntoa(sadr.sin_addr));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nClientCnt++;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("+++Received connection from %s client cnt=%d\n",inet_ntoa(sadr.sin_addr),nClientCnt);<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(0!=pthread_create(&amp;thread_id,0,&amp;SocketHandler, (void*)csock ))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Error create thread !!! %s\n", strerror(errno) );<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(0 != pthread_detach(thread_id) )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Error : pthread_detach [%s]\n", strerror(errno));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("Error accepting %d\n", errno);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; <br />FINISH:<br />&nbsp;&nbsp;&nbsp; return 0;<br />}<br /><br />//---------------------------------------<br />void* SocketHandler(void* lp)<br />{<br />&nbsp;&nbsp;&nbsp; int *csock = (int*)lp;<br /><br />&nbsp;&nbsp;&nbsp; char buffer[1024];<br />&nbsp;&nbsp;&nbsp; int buffer_len = 1024;<br />&nbsp;&nbsp;&nbsp; int recvlen = 0;<br />&nbsp;&nbsp;&nbsp; int sentlen = 0;<br /><br />&nbsp;&nbsp;&nbsp; while(1)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memset(buffer, 0, buffer_len);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recvlen = recv(*csock, buffer, buffer_len, 0);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(recvlen == 0 )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //printf( "[%d] recv 0 \n", *csock);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto FINISH;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(recvlen &lt; 0 )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf( "[%d] Error receiving data %s\n", *csock, strerror(errno) );<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto FINISH;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //printf("[%d] Received bytes %d\n", *csock, recvlen);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sentlen = send(*csock, buffer, recvlen, 0);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(sentlen != recvlen)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( "[%d] Error sent len = %d\n",*csock,&nbsp; sentlen);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto FINISH;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if(sentlen == -1)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( "[%d] Error sending data %d\n",*csock,&nbsp; errno);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto FINISH;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //printf("[%d] Sent bytes %d\n",*csock, sentlen);<br />&nbsp;&nbsp;&nbsp; }<br /><br /><br />FINISH:<br />&nbsp;&nbsp;&nbsp; close(*csock);<br />&nbsp;&nbsp;&nbsp; //printf("***************** socket [%d] closed \n", *csock);<br />&nbsp;&nbsp;&nbsp; free(csock);<br />&nbsp;&nbsp;&nbsp; return 0;<br />}<br /><br /><br /><span style="color: red;"><b>//////////////// CLIENT ////////////////////////</b></span><br /><br />#include &lt;fcntl.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;errno.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;netinet/in.h&gt;<br />#include &lt;resolv.h&gt;<br />#include &lt;sys/socket.h&gt;<br />#include &lt;arpa/inet.h&gt;<br />#include &lt;unistd.h&gt;<br />#include &lt;pthread.h&gt;<br />#include &lt;signal.h&gt;<br /><br />#include &lt;sys/time.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;math.h&gt;<br /><br />int nConnected = 0;<br />/* Return 1 if the difference is negative, otherwise 0.&nbsp; */<br />int timeval_subtract(struct timeval *result, struct timeval *t2, struct timeval *t1)<br />{<br />&nbsp;&nbsp;&nbsp; long int diff = (t2-&gt;tv_usec + 1000000 * t2-&gt;tv_sec) - (t1-&gt;tv_usec + 1000000 * t1-&gt;tv_sec);<br />&nbsp;&nbsp;&nbsp; result-&gt;tv_sec = diff / 1000000;<br />&nbsp;&nbsp;&nbsp; result-&gt;tv_usec = diff % 1000000;<br /><br />&nbsp;&nbsp;&nbsp; return (diff&lt;0);<br />}<br /><br />void timeval_print(struct timeval *tv)<br />{<br />&nbsp;&nbsp;&nbsp; char buffer[30];<br />&nbsp;&nbsp;&nbsp; time_t curtime;<br /><br />&nbsp;&nbsp;&nbsp; //printf("%ld.%06ld", tv-&gt;tv_sec, tv-&gt;tv_usec);<br />&nbsp;&nbsp;&nbsp; curtime = tv-&gt;tv_sec;<br />&nbsp;&nbsp;&nbsp; strftime(buffer, 30, "%m-%d-%Y&nbsp; %T", localtime(&amp;curtime));<br />&nbsp;&nbsp;&nbsp; //printf(" = %s.%06ld\n", buffer, tv-&gt;tv_usec);<br />}<br /><br />///////////////////////////////////////////////////////////////////////////////<br />void* ClientThread (void* lp)<br />{<br />&nbsp;&nbsp;&nbsp; struct timeval tvBegin, tvEnd, tvDiff;<br /><br />&nbsp;&nbsp;&nbsp; int host_port= 1101;<br />&nbsp;&nbsp;&nbsp; //char* host_name="127.0.0.1";<br />&nbsp;&nbsp;&nbsp; char host_name[20];<br />&nbsp;&nbsp;&nbsp; snprintf(host_name, sizeof(host_name), "%s", "127.0.0.1");<br /><br />&nbsp;&nbsp;&nbsp; struct sockaddr_in my_addr;<br /><br />&nbsp;&nbsp;&nbsp; char buffer[700];<br />&nbsp;&nbsp;&nbsp; int bytecount;<br />&nbsp;&nbsp;&nbsp; int buffer_len=0;<br /><br />&nbsp;&nbsp;&nbsp; int hsock;<br />&nbsp;&nbsp;&nbsp; int err;<br /><br />&nbsp;&nbsp;&nbsp; hsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP ); //XXX <br />&nbsp;&nbsp;&nbsp; if(hsock == -1)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("Error initializing socket %s\n",strerror(errno) );<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto FINISH;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; my_addr.sin_family = AF_INET ;<br />&nbsp;&nbsp;&nbsp; my_addr.sin_port = htons(host_port);<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; memset(&amp;(my_addr.sin_zero), 0, 8);<br />&nbsp;&nbsp;&nbsp; my_addr.sin_addr.s_addr = inet_addr(host_name);<br /><br />&nbsp;&nbsp;&nbsp; // begin<br />&nbsp;&nbsp;&nbsp; gettimeofday(&amp;tvBegin, NULL);<br />&nbsp;&nbsp;&nbsp; timeval_print(&amp;tvBegin);<br /><br />&nbsp;&nbsp;&nbsp; if( connect( hsock, (struct sockaddr*)&amp;my_addr, sizeof(my_addr)) == -1 )<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; err = errno;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(err == EINPROGRESS)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("Error connecting socket : EINPROGRESS \n");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if(err != EINPROGRESS)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("Error connecting socket %s\n", strerror(errno) );<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto FINISH;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; //end<br />&nbsp;&nbsp;&nbsp; gettimeofday(&amp;tvEnd, NULL);<br />&nbsp;&nbsp;&nbsp; timeval_print(&amp;tvEnd);<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; nConnected++;<br /><br />&nbsp;&nbsp;&nbsp; // diff<br />&nbsp;&nbsp;&nbsp; timeval_subtract(&amp;tvDiff, &amp;tvEnd, &amp;tvBegin);<br />&nbsp;&nbsp;&nbsp; //printf("connected [%d]!! elapsed: %ld.%06ld\n",nConnected, tvDiff.tv_sec, tvDiff.tv_usec);<br /><br />&nbsp;&nbsp;&nbsp; //usleep(1000); //TEST ????<br /><br />&nbsp;&nbsp;&nbsp; buffer_len = 694;<br />&nbsp;&nbsp;&nbsp; memset(buffer, '1', buffer_len);<br /><br />&nbsp;&nbsp;&nbsp; bytecount=send(hsock, buffer, buffer_len ,0);<br /><br />&nbsp;&nbsp;&nbsp; if( bytecount &lt; 0 )<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf( "Error sending data %s\n", strerror(errno));<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto FINISH;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; else if( bytecount!= buffer_len )<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf( "Error sending data :sent %d\n", bytecount );<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto FINISH;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; //printf("Sent bytes %d\n", bytecount);<br /><br />&nbsp;&nbsp;&nbsp; bytecount = recv(hsock, buffer, buffer_len, 0);<br />&nbsp;&nbsp;&nbsp; if(bytecount == 0 )<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("Error receiving data is 0!\n" );<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto FINISH;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; else if(bytecount &lt; 0 )<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("Error receiving data %s\n", strerror(errno) );<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto FINISH;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; //printf("--OK Recieved bytes %d\n",&nbsp; bytecount);<br /><br />FINISH:<br />&nbsp;&nbsp;&nbsp; close(hsock);<br />&nbsp;&nbsp;&nbsp; return NULL;<br />}<br /><br />//No signal!!!<br />void SigPipeHandler (int signo)<br />{<br />&nbsp;&nbsp;&nbsp; printf("SIGPIPE!!!\n");<br />}<br /><br />///////////////////////////////////////////////////////////////////////////////<br />int main(int argv, char** argc)<br />{<br />&nbsp;&nbsp;&nbsp; //signal <br />&nbsp;&nbsp;&nbsp; struct sigaction pipesig;<br />&nbsp;&nbsp;&nbsp; pipesig.sa_handler = SigPipeHandler;<br />&nbsp;&nbsp;&nbsp; sigemptyset(&amp;pipesig.sa_mask);<br />&nbsp;&nbsp;&nbsp; pipesig.sa_flags = 0;<br /><br />&nbsp;&nbsp;&nbsp; if (sigaction(SIGPIPE, &amp;pipesig, 0) == -1)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ("signal(SIGPIPE) error");<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br />&nbsp;&nbsp;&nbsp; } <br /><br />&nbsp;&nbsp;&nbsp; /////////////////////////<br />&nbsp;&nbsp;&nbsp; pthread_t pthread_array [2048]; <br />&nbsp;&nbsp;&nbsp; struct timeval tvBegin, tvEnd, tvDiff;<br />&nbsp;&nbsp;&nbsp; // begin<br />&nbsp;&nbsp;&nbsp; gettimeofday(&amp;tvBegin, NULL);<br />&nbsp;&nbsp;&nbsp; timeval_print(&amp;tvBegin);<br /><br />&nbsp;&nbsp;&nbsp; int nTotalThread = atoi( argc[1]);<br />&nbsp;&nbsp;&nbsp; printf("total thread =%d\n", nTotalThread );<br /><br />&nbsp;&nbsp;&nbsp; for(int i = 0; i &lt; nTotalThread; i++)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(0!=pthread_create(&amp;pthread_array[i],0,&amp;ClientThread, NULL ))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("Error create thread !!! %s\n", strerror(errno) );<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //pthread_detach(thread_id);<br />&nbsp;&nbsp;&nbsp; }<br /><br /><br />&nbsp;&nbsp;&nbsp; for(int i = 0; i &lt; nTotalThread; i++)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int status;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(0!=pthread_join(pthread_array[i], (void**) &amp;status ))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("Error pthread_join&nbsp; !!! %s\n", strerror(errno) );<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; //end<br />&nbsp;&nbsp;&nbsp; gettimeofday(&amp;tvEnd, NULL);<br />&nbsp;&nbsp;&nbsp; timeval_print(&amp;tvEnd);<br /><br />&nbsp;&nbsp;&nbsp; // diff<br />&nbsp;&nbsp;&nbsp; timeval_subtract(&amp;tvDiff, &amp;tvEnd, &amp;tvBegin);<br />&nbsp;&nbsp;&nbsp; printf("----------- total test elapsed: %ld.%06ld\n", tvDiff.tv_sec, tvDiff.tv_usec);<br /><br /><br />&nbsp;&nbsp;&nbsp; return 0;<br />}<br /><br /><span style="color: red;">///////////////////////////////////// SH //////////////////////////////////</span><br /><br /><br />#!/bin/bash<br /><br />for i in {1..100}<br />do<br />&nbsp;&nbsp;&nbsp; #time ./LinClient 120 | grep OK | wc -l<br />&nbsp;&nbsp;&nbsp; #./LinClient 100<br />&nbsp;&nbsp;&nbsp; #sleep 0.15<br /><br />&nbsp;&nbsp;&nbsp; ./LinClient 200<br /><br />&nbsp;&nbsp;&nbsp; #sleep 0.05<br />done<br /><br /><br /><br /><br />