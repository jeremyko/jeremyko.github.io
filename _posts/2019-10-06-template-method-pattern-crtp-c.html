---
layout: post
title: template method pattern 에  CRTP 사용하기 (c++)
date: '2019-10-06T16:52:00.001+09:00'
author: jeremyko
tags:
- cpp
- template method pattern
- CRTP
modified_time: '2022-03-26T20:56:32.844+09:00'
blogger_id: tag:blogger.com,1999:blog-7360229670252766698.post-597786629018288037
blogger_orig_url: https://jeremyko.blogspot.com/2019/10/template-method-pattern-crtp-c.html
---

<p>그동안 개발하면서 template method pattern을 즐겨 사용하고 있는데, virtual 함수를 이용하여 구현했었다. 그런데 CRTP 를 이용해도 비슷한(동일한건 아님) 처리가 가능하다. <br /><br />예를 들어 다음처럼 template method pattern 구현을 한경우, <br /></p><span><a name='more'></a></span><p><!--HTML generated using hilite.me--><br /></p><div style="background: rgb(255, 255, 255) none repeat scroll 0% 0%; border-width: 0.1em 0.1em 0.1em 0.8em; border: medium solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0px;"></pre></td><td><pre style="line-height: 125%; margin: 0px;"><span style="color: #4c8317;">#include &lt;iostream&gt;</span><br /><span style="color: #4c8317;">#include &lt;memory&gt;</span><br /><span style="color: #4c8317;">#include &lt;vector&gt;</span><br /><br /><span style="color: #0000aa;">template</span>&lt;<span style="color: #0000aa;">typename</span> T, <span style="color: #0000aa;">typename</span>... Args&gt;<br />std::unique_ptr&lt;T&gt; make_unique(Args&amp;&amp;... args)<br />{<br />    <span style="color: #0000aa;">return</span> std::unique_ptr&lt;T&gt;(<span style="color: #0000aa;">new</span> T(std::forward&lt;Args&gt;(args)...));<br />}<br /><br /><span style="color: #0000aa;">class</span> <span style="color: #00aa00; text-decoration: underline;">Base</span> {<br />    public:<br />        <span style="color: #0000aa;">virtual</span> ~Base() {}<br /><br />        <span style="color: #00aaaa;">void</span> DoWork() { <br />            DoBasicWork();<br />            DoSpecialWork();<br />        }<br />        <span style="color: #00aaaa;">void</span> DoBasicWork(){<br />            std::cout &lt;&lt; <span style="color: #aa5500;">"Do Basic work..\n"</span>;<br />        }<br />        <span style="color: #0000aa;">virtual</span> <span style="color: #00aaaa;">void</span> DoSpecialWork() = <span style="color: #009999;">0</span>;<br />};<br /><br /><span style="color: #0000aa;">class</span> <span style="color: #00aa00; text-decoration: underline;">Derived1</span> : <span style="color: #0000aa;">public</span> Base<br />{<br />    public:<br />        <span style="color: #00aaaa;">void</span> DoSpecialWork() override {<br />            std::cout &lt;&lt; <span style="color: #aa5500;">"Do derived 1's special work..\n"</span>;<br />        }<br />};<br /><br /><span style="color: #0000aa;">class</span> <span style="color: #00aa00; text-decoration: underline;">Derived2</span> : <span style="color: #0000aa;">public</span> Base<br />{<br />    public:<br />        <span style="color: #00aaaa;">void</span> DoSpecialWork() override {<br />            std::cout &lt;&lt; <span style="color: #aa5500;">"Do derived 2's special work..\n"</span>;<br />        }<br />};<br /><br /><span style="color: #00aaaa;">int</span> <span style="color: #00aa00;">main</span>()<br />{<br />    std::vector&lt;std::unique_ptr&lt;Base&gt;&gt; vec_base;<br />    vec_base.push_back(make_unique&lt;Derived1&gt;());<br />    vec_base.push_back(make_unique&lt;Derived2&gt;());<br />    <span style="color: #0000aa;">for</span>(<span style="color: #0000aa;">auto</span> it = vec_base.begin(); it != vec_base.end(); ++it){<br />        (*it)-&gt;DoWork();<br />    }<br />    <span style="color: #0000aa;">return</span> <span style="color: #009999;">0</span>;<br />}<br /></pre></td></tr></tbody></table></div><br /><br />CRTP 를 이용해서 (비슷하게) 다시 구현하면 다음과 같다. 동적 다형성(dynamic polymorphism)을 희생한 경우이다.<br /><!--HTML generated using hilite.me--><br /><div style="background: rgb(255, 255, 255) none repeat scroll 0% 0%; border-width: 0.1em 0.1em 0.1em 0.8em; border: medium solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0px;"></pre></td><td><pre style="line-height: 125%; margin: 0px;"><span style="color: #4c8317;">//.... 생략 ....</span><br /><span style="color: #0000aa;">template</span>&lt;<span style="color: #0000aa;">typename</span> Derived&gt;<br /><span style="color: #0000aa;">class</span> <span style="color: #00aa00; text-decoration: underline;">Base</span> <br />{<br />    public:<br />        <span style="color: #0000aa;">virtual</span> ~Base() {}<br />        <span style="color: #00aaaa;">void</span> DoWork() { <br />            DoBasicWork();<br />            <span style="color: #0000aa;">static_cast</span>&lt;Derived*&gt;(<span style="color: #0000aa;">this</span>)-&gt;DoSpecialWork();<br />        }<br />        <span style="color: #00aaaa;">void</span> DoBasicWork(){<br />            std::cout &lt;&lt; <span style="color: #aa5500;">"Do Basic work..\n"</span>;<br />        }<br />};<br /><br /><span style="color: #0000aa;">class</span> <span style="color: #00aa00; text-decoration: underline;">Derived1</span> : <span style="color: #0000aa;">public</span> Base&lt;Derived1&gt;<br />{<br />    public:<br />        <span style="color: #00aaaa;">void</span> DoSpecialWork(){<br />            std::cout &lt;&lt; <span style="color: #aa5500;">"Do derived 1's special work..\n"</span>;<br />        }<br />};<br /><br /><span style="color: #0000aa;">class</span> <span style="color: #00aa00; text-decoration: underline;">Derived2</span> : <span style="color: #0000aa;">public</span> Base&lt;Derived2&gt;<br />{<br />    public:<br />        <span style="color: #00aaaa;">void</span> DoSpecialWork(){<br />            std::cout &lt;&lt; <span style="color: #aa5500;">"Do derived 2's special work..\n"</span>;<br />        }<br />};<br /><br /><span style="color: #00aaaa;">int</span> <span style="color: #00aa00;">main</span>()<br />{    <br />    Derived1 child1;<br />    Derived2 child2;<br />    child1.DoWork();<br />    child2.DoWork();<br />    <span style="color: #0000aa;">return</span> <span style="color: #009999;">0</span>;<br />}</pre></td></tr></tbody></table></div><br />처음 예제와 같이 STL Container 에 저장하는 등의 동적 다형성이 필요하다면, 가상함수를 사용할수 밖에 없지만, 두번째 예제와 같은식으로 사용하는것으로 충분하다면 CRTP 를 이용한 방식도 고려해볼만 하겠다.<br /><br /><br /><br /><span><!--more--></span>