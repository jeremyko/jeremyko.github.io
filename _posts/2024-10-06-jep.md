---
layout: post
title: 'tablesaw, jep : java 에서 pandas를 사용하기'
date: 2024-10-06 21:40:00 +0900

tags: [java, tablesaw, jep, python, numpy, pandas]
---

**java에서 python 코드를 사용하려면 jep 을 이용해서 기존코드 (파이선모듈의 C 종속성 상관없이)를 그대로 활용할수 있다**
{: .notice--primary}

기존에 python pandas로 작성된 코드를 java 환경에서 사용해야 하는 경우가 있다. pandas 는 기여자만 3000 명이 넘는, 수많은 기능을 포함하고 있는 방대한 라이브러리다. 이런 라이브러리를 이용해서 개발된 python 코드를 어떻게 java 에서 어떻게 사용할 것인가? 그 방법을 찾다보니 알게된 **`tablesaw`** 와 **`jep`** 이라는 오픈소스에 대해 간단히 적어본다. 

## [tablesaw](https://github.com/jtablesaw/tablesaw) ## 

pandas 의 dataframe 과 비슷한 **`Table`** 이라는 클래스를 제공한다. 단어 그대로 데이터들로 구성된 단순한 테이블이다. 

pandas 의 index 라는 개념은 없고, 그냥 column, row 만 존재한다. import, export, 필터링 등  기능을 제공하지만 pandas 에 비해 많이 부족한 수준이다. 그리고 신규 개발이 거의 중단 상태로 보인다. 

이것은 pandas를 대신 할 수 있는게 아니고 직접 구현할 때 필요한 일부 기능이라고 할수 있다. 
그래서 필요한데 제공 안되는 함수는 직접 로직을 구현해야 한다. (~~예?~~).  

예를들어 `pivot` 의 경우, 아주 간단하게 제공을 해주지만 pandas 에서 사용하던 방식대로 사용하려면 직접 그 로직을 구현해야 한다.

`merge` 도 마찬가지로 pandas 처럼 다양한 방식으로 사용할 수 없다. pandas 에서 함수 인자를 어떻게 사용하느냐에 따라 결과가 달라지는 그 모든것을 일일히 다 구현 해줘야 한다.
 
그나마 위 경우는 비슷한 기능을 제공이라도 하지만 없는것이 대부분이다 . `vectorization` 도 지원하지 않는다 (~~당신이 for loop 로 직접 구현해야~~). 

![image](/assets/img/20241006_1.jpg){: width="400"}

최근 프로젝트에서 알아볼 시간도 없어서 그냥 이것으로 개발했는데, pandas 함수를 java 에서 tablesaw 이용해서 구현하고 결과가 python 과 동일한지 전부 검증 하는 방식으로 개발을 해야 했다. 하다보니 이런 식으로 개발 하는것은 전혀 바람직하지 않다는 시행 착오를 겪게 되었다.


## [jep](https://github.com/ninia/jep) ## 


java 에 임베디드된 python 으로, JNI 와 CPython API 를 이용해서 JVM 내부에서 Python 인터프리터를 시작해서 python 호출을 가능하게 해준다. 

**python interpreter 가 python 코드를 수행하는 것이니, 이미 작성되어 있는 python 코드를 아무런 수정없이 실행 가능하다 (이것이 pandas, numpy 등 C 에 종속된 특정 python 모듈 사용도 가능한 큰 장점임).**

그리고 jep 은 java, python 간에 데이터를 연동 할 수 있게 해준다.

![호오](/assets/img/pepe_good.jpg){: width="200"}

지금부터 jep 설치와 예제를 수행 해 보도록 한다.

다음처럼 설치 하면

    pip install jep

python 모듈 저장소에 jar 파일이 저장된다 (windows기준). 

    C:\Python311\Lib\site-packages\jep\jep-4.2.0.jar

이것을 classpath 에 추가한다
(intellij 등의 IDE 를 사용하는 경우에는 라이브러리로 추가).

그리고 window 환경변수 path 에 다음 경로를 추가한다 
    
    C:\Python311\Lib\site-packages\jep

java 에서 python 을 실행하는것은 다음과 같다.

```java
package org.kojh;

import java.nio.file.Files;
import java.nio.file.Path;
import jep.Interpreter;
import jep.SharedInterpreter;

public class Main {

    public static void main(String[] args) throws Exception{
        try (Interpreter interp = new SharedInterpreter()) {
            interp.exec("import pandas as pd");
            interp.exec("import numpy as np");
            interp.exec("dates = pd.date_range('1/1/2000', periods=8)");
            interp.exec("df = pd.DataFrame(np.random.randn(8, 4), index=dates, columns=['A', 'B', 'C', 'D'])");
            Object result1 = interp.getValue("df");
            System.out.println(result1);            
        }
    }
}
```

python 스크립트 파일도 실행 가능하다.  
다음과 같이 `test.py` 라는 python 코드를 java 에서 호출하는 경우를 가정해본다.

```python
import pandas as pd
import numpy as np

df1 = pd.DataFrame({'lkey': ['foo', 'bar', 'baz', 'foo'], 'value': [1, 2, 3, 5]})
df2 = pd.DataFrame({'rkey': ['foo', 'bar', 'baz', 'foo'], 'value': [5, 6, 7, 8]})
merged1 = df1.merge(df2, left_on='lkey', right_on='rkey')
merged2 = df1.merge(df2, left_on='lkey', right_on='rkey', suffixes=('_left', '_right'))

df = pd.DataFrame({'a': [10., 20., 30., 40., 50.],
                   'b': [None, None, None, None, 500]},
                  index=pd.DatetimeIndex(['2018-02-27 09:01:00',
                                          '2018-02-27 09:02:00',
                                          '2018-02-27 09:03:00',
                                          '2018-02-27 09:04:00',
                                          '2018-02-27 09:05:00']))
asof_result = df.asof(pd.DatetimeIndex(['2018-02-27 09:03:30', '2018-02-27 09:04:30']))          
```

그럼 다음처럼 호출해서 python 코드내의 변수 df에 접근할수 있다.

```java
package org.kojh;

import java.nio.file.Files;
import java.nio.file.Path;
import jep.Interpreter;
import jep.SharedInterpreter;

public class Main {

    public static void main(String[] args) throws Exception{
        try (Interpreter interp = new SharedInterpreter()) {
            Path filePath = Path.of("test.py");
            String pyCode = Files.readString(filePath);
            interp.exec(pyCode);
            
            Object result = interp.getValue("merged1");
            System.out.println(result);
            result = interp.getValue("asof_result");
            System.out.println(result);
        }
    }
}
```

jep을 사용해서 java에서 numpy 를 직접 사용하기
{: .notice--info}

위 사용법처럼 java 에서 python 코드를 실행할때 numpy 사용 부분도 문제 없이 실행되는 것을 알 수 있었다. python interpreter 가 임베디드 되어 돌아가는 것이니, 당연히 python 코드 내에서 그 어떤 모듈도 문제없이 사용할 수 있다. 

그런데 java 에서 직접 numpy 함수를 호출하면서 (python interpreter에서 수행되는게 아닌) 인자를 전달하고 그 결과도 받고 이런 작업을 하려면 jep 소스를 직접 컴파일 해서 jar 및 운영체계에 맞는 dll, 공유라이브러리 등을 재빌드 해야 한다.

먼저 다음 코드로 jep에서 numpy 직접 사용이 가능한 지 확인할 수 있다.

```java
interp.exec("result = jep.JEP_NUMPY_ENABLED");
System.out.println( interp.getValue("result")); // 0 or 1
```
1 이 출력되면 사용가능한것이고 0 이 출력되면 재빌드가 필요하다. 지금 상태에서는 0이 출력될 것이다.

여기서 [Numpy-Usage 공식 예제](https://github.com/ninia/jep/wiki/Numpy-Usage) 하나를 수행 해 보면

```java
try(SharedInterpreter interp = new SharedInterpreter()) {
   float[] f = new float[] { 1.0f, 2.1f, 3.3f, 4.5f, 5.6f, 6.7f };
   NDArray<float[]> nd = new NDArray<>(f, 3, 2);
   interp.set("x", nd);
   
   interp.exec("type = type(x)");    
   System.out.println( interp.getValue("type"));   
}

// <class 'jep.NDArray'>  
```
제대로 동작하는 경우에는 인터프리터 내부에서 x라는 변수는 numpy.ndarray 타입의 shape는 (3,2)가 될것이고, `<class 'numpy.ndarray'>` 가 출력 되어야 한다.  
그런데 `<class 'jep.NDArray'>` 가 출력되고 있으니 재빌드가 필요하다.

가장 먼저 할일은 numpy 부터 설치하는 것이다. jep 을 빌드할때 numpy 존재 여부를 먼저 확인하고 처리하기 때문이다. numpy 를 나중에 설치한다면 빌드를 다시 해야 한다.
    
    pip install numpy
    
jep 소스를 받는다

    git clone https://github.com/ninia/jep.git

그리고 컴파일 수행

    python setup.py build
    
만약 다음과 같은 경고가 발생한다면

    SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools.

setuptools 다운그레이드가 필요하다 (최신 버전으로는 성공하지 못했다) .

    pip install setuptools==58.2.0     

그리고 다시 컴파일을 수행한다

    python setup.py build
    
다음처럼 numpy 설치여부를 확인해서, lib 를 다시 만드는 것을 볼수 있다.
  
    jerem: ~/Downloads/mydev/java_dev/jep4.2.0# python setup.py build
    numpy include found at C:\Python311\Lib\site-packages\numpy\core\include
    running build
    ...
    creating build\lib.win-amd64-3.11
    creating build\lib.win-amd64-3.11\jep
    copying src\main\python\jep\console.py -> build\lib.win-amd64-3.11\jep
    ...
    building 'jep' extension
    creating build\temp.win-amd64-3.11    
    ...
    4-3.11\jep\jep.cp311-win_amd64.pyd
       build\lib.win-amd64-3.11\jep\jep.cp311-win_amd64.lib 라이브러리 및 build\lib.win-amd64-3.11\jep\jep.cp311-win_amd64.exp 개체를 생성하고 있습니다.
    코드를 생성하고 있습니다.
    코드를 생성했습니다.
    copying build\lib.win-amd64-3.11\jep\jep.cp311-win_amd64.pyd -> build\lib.win-amd64-3.11\jep\jep.cp311-win_amd64.dll
    running build_scripts
    creating build\scripts-3.11

install 을 수행 
    
    python setup.py install

python 모듈이 설치되는것을 확인한다.
    
    Installed c:\python311\lib\site-packages\jep-4.2.0-py3.11-win-amd64.egg
    Processing dependencies for jep==4.2.0
    Finished processing dependencies for jep==4.2.0

내 경우에는 다음 경로에 설치가 되었다.

    C:\Python311\Lib\site-packages\jep-4.2.0-py3.11-win-amd64.egg

혼란을 막기 위해 기존 설치한 jep 은 삭제했다. 

    pip uninstall jep
    
이제 처음에 했던것과 동일하게 classpath 에 추가 및 window 환경변수 path 에 새로운 경로를 추가 해주면 된다. 

classpath 추가

    C:\Python311\Lib\site-packages\jep-4.2.0-py3.11-win-amd64.egg\jep\jep-4.2.0.jar 

환경변수 추가 

    C:\Python311\Lib\site-packages\jep-4.2.0-py3.11-win-amd64.egg\jep

제대로 동작하는지 확인해 본다.
```java
try (Interpreter interpreter = new SharedInterpreter()) {
    interpreter.exec("import pandas as pd");
    interpreter.exec("import numpy as np");
    interpreter.exec("result = jep.JEP_NUMPY_ENABLED");
    System.out.println( interpreter.getValue("result")); 

    // For ease and speed of copying the arrays between the two languages, 
    // the Java arrays must be one dimensional.
    float[] f = new float[] { 1.0f, 2.1f, 3.3f, 4.5f, 5.6f, 6.7f };
    
    NDArray<float[]> nd = new NDArray<>(f, 3, 2);
    interpreter.set("x", nd);
    interpreter.exec("type = type(x)"); 
    interpreter.exec("shape = x.shape"); 
    interpreter.exec("df = pd.DataFrame( np.array(x) ) ");
    System.out.println( interpreter.getValue("type"));
    System.out.println( interpreter.getValue("shape"));
    System.out.println( interpreter.getValue("df"));
}
// 1
// <class 'numpy.ndarray'>
// [3, 2]
```




## [jython](https://www.jython.org/), [GraalPy](https://www.graalvm.org/latest/reference-manual/python/)  ##

java와 python 을 연동하는것이 jep 만 있는건 아니다.  

그런데 numpy (pandas) 등과 같이 C 언어에 종속성을 가진 python 모듈은 지원 안될 수 있다. 예를 들어 `jython` 이라는 것도 있지만 pandas, numpy 를 사용할수 없다. 

오라클에서 만든 `GraalPy` (~~지랄파이~~)도 있는데, 이건 Python 뿐 아니라 JavaScript 등의 여러 언어를 내장하여 Java 애플리케이션을 확장할 수 있다고 한다.  

그런데 테스트 해보니 일단 windows에서는 [제약](https://www.graalvm.org/latest/reference-manual/python/Python-Runtime/#windows)이 많아서 pandas 사용은 불가능했다.  
linux 인 경우에는 동작은 하는데, 약 30배 정도 속도 저하가 발생되었다. 그리고 장점으로 내세우고 있는 네이티브 바이너리로 컴파일 가능한 것도 시간이 너무 많이 걸렸다 (아주 간단한 것도 거의 10분).

## 참고 ##

[https://github.com/ninia/jep/wiki/Getting-Started](https://github.com/ninia/jep/wiki/Getting-Started)  
[https://github.com/ninia/jep/wiki/Numpy-Usage](https://github.com/ninia/jep/wiki/Numpy-Usage)  
[https://github.com/ninia/jep/issues/560](https://github.com/ninia/jep/issues/560)  
[https://github.com/ninia/jep/wiki/Windows](https://github.com/ninia/jep/wiki/Windows)  

