---
layout: post
title: 'CumBuffer : accumulating byte buffer for c++ '
date: '2016-12-12T22:55:00.002+09:00'
author: jeremyko
tags:
- cpp
- CumBuffer
modified_time: '2022-03-26T21:02:08.367+09:00'
blogger_id: tag:blogger.com,1999:blog-7360229670252766698.post-1865585647397958715
blogger_orig_url: https://jeremyko.blogspot.com/2016/12/cumbuffer-accumulating-buffer-for-c.html
---

<br />네트워크 TCP 프로그램인 경우에 임의 길이의 작은 데이터 조각을 수신해서 누적(버퍼링)시키다가 일정 길이가 수신되면 완전한 하나의 packet으로 보고 해당 데이터를 처리하는 경우가 꼭 필요하다. 지금까지는 그냥 new, calloc 등으로 데이터를 수신할때마다 동적으로 할당해서 기존 데이터를 복사하는 방식으로 해왔는데(동적할당 제거에 의한 성능개선이 크지 않았기에), 이번에 동적 할당없이 사용할 수 있는 버퍼를 구현해 보았다. 일종의 ring buffer 라고도 할수 있다.<br /><br /><a href="https://github.com/jeremyko/CumBuffer" target="_blank">https://github.com/jeremyko/CumBuffer</a><br /><br /><a name='more'></a><span style="font-family: &quot;verdana&quot; , sans-serif;"><span style="white-space: pre;"><b><br /></b></span></span> <span style="font-family: &quot;verdana&quot; , sans-serif;"><span style="white-space: pre;"><b>기본 사용법</b></span></span><br /><br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39<br />40<br />41<br />42<br />43<br />44<br />45<br />46<br />47<br />48<br />49<br />50<br />51<br />52<br />53<br />54<br />55<br />56</pre></td><td><pre style="line-height: 125%; margin: 0;"><span style="color: #4c8317;">#include "CumBuffer.h"</span><br /> <br />CumBuffer buffering;<br />   <br /><span style="color: #0000aa;">if</span>(cumbuffer_defines::OP_RSLT_OK == buffering.Init(<span style="color: #009999;">9</span>)) <span style="color: #aaaaaa; font-style: italic;">//버퍼길이 9 byte로 초기화</span><br />{<br />    <span style="color: #0000aa;">return</span> <span style="color: #00aaaa;">false</span>;<br />}<br />   <br /><span style="color: #00aaaa;">char</span> data   [<span style="color: #009999;">100</span>];<br /><span style="color: #00aaaa;">char</span> dataOut[<span style="color: #009999;">100</span>];<br />   <br /><span style="color: #aaaaaa; font-style: italic;">//3 byte 저장</span><br />memset(data, <span style="color: #009999;">0x00</span>, <span style="color: #0000aa;">sizeof</span>(data));<br />memcpy(data, (<span style="color: #00aaaa;">void</span>*)<span style="color: #aa5500;">"aaa"</span>, <span style="color: #009999;">3</span>);<br /><span style="color: #0000aa;">if</span>(cumbuffer_defines::OP_RSLT_OK != buffering.Append(<span style="color: #009999;">3</span>, data))<br />{<br />    <span style="color: #0000aa;">return</span> <span style="color: #00aaaa;">false</span>;<br />}<br /> <br /><span style="color: #aaaaaa; font-style: italic;">//4 byte 저장</span><br />memset(data, <span style="color: #009999;">0x00</span>, <span style="color: #0000aa;">sizeof</span>(data));<br />memcpy(data, (<span style="color: #00aaaa;">void</span>*)<span style="color: #aa5500;">"abbb"</span>, <span style="color: #009999;">4</span>);<br /><span style="color: #0000aa;">if</span>(cumbuffer_defines::OP_RSLT_OK != buffering.Append(<span style="color: #009999;">4</span>, data))<br />{<br />    <span style="color: #0000aa;">return</span> <span style="color: #00aaaa;">false</span>;<br />}<br /> <br /><span style="color: #0000aa;">if</span>(buffering.GetCumulatedLen()!=<span style="color: #009999;">7</span>) <span style="color: #aaaaaa; font-style: italic;">//현재까지 저장된 데이터 길이 7</span><br />{<br />    <span style="color: #0000aa;">return</span> <span style="color: #00aaaa;">false</span>;<br />}<br /> <br /><span style="color: #aaaaaa; font-style: italic;">//4 byte 추출</span><br />memset(dataOut, <span style="color: #009999;">0x00</span>, <span style="color: #0000aa;">sizeof</span>(dataOut));<br /><span style="color: #0000aa;">if</span>(cumbuffer_defines::OP_RSLT_OK != buffering.GetData(<span style="color: #009999;">4</span>, dataOut))<br />{<br />    <span style="color: #0000aa;">return</span> <span style="color: #00aaaa;">false</span>;<br />}<br /> <br /><span style="color: #0000aa;">if</span>( strcmp(<span style="color: #aa5500;">"aaaa"</span>, dataOut)!=<span style="color: #009999;">0</span>)<br />{<br />    <span style="color: #0000aa;">return</span> <span style="color: #00aaaa;">false</span>;<br />}<br />   <br /><span style="color: #aaaaaa; font-style: italic;">//3 byte 추출</span><br />memset(dataOut, <span style="color: #009999;">0x00</span>, <span style="color: #0000aa;">sizeof</span>(dataOut));<br /><span style="color: #0000aa;">if</span>(cumbuffer_defines::OP_RSLT_OK != buffering.GetData(<span style="color: #009999;">3</span>, dataOut))<br />{<br />    <span style="color: #0000aa;">return</span> <span style="color: #00aaaa;">false</span>;<br />}<br /> <br /><span style="color: #0000aa;">if</span>( strcmp(<span style="color: #aa5500;">"bbb"</span>, dataOut)!=<span style="color: #009999;">0</span>)<br />{<br />    <span style="color: #0000aa;">return</span> <span style="color: #00aaaa;">false</span>;<br />}<br /></pre></td></tr></tbody></table></div><br /><b>동적 할당과 비교를 위한 benchmark 소스</b><br /><pre class="textmate-source"><span style="font-family: inherit;"><a href="https://gist.github.com/jeremyko/5ddd7796da25918962da0f6ad34e02ae" target="_blank">https://gist.github.com/jeremyko/5ddd7796da25918962da0f6ad34e02ae</a>&nbsp;</span></pre><pre class="textmate-source"></pre><br /><br />