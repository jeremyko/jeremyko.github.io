---
layout: post
title: Expression template
date: '2009-08-03T18:03:00.000+09:00'
author: jeremyko
tags:
- cpp
- RVO
- 템플릿
- Expression template
modified_time: '2016-09-09T17:52:18.993+09:00'
blogger_id: tag:blogger.com,1999:blog-7360229670252766698.post-6899605960372039055
blogger_orig_url: https://jeremyko.blogspot.com/2009/08/expression-template.html
---

<div style="font-family: inherit;"><span style="font-size: small;">Expression  template 은 과학, 수치 계산용 프로그램 같은, 고도의&nbsp; 성능이 중요시되는 코드를 작성하기 위한 방법으로 C++의 템플릿  을 활용한 것이다. 템플릿은&nbsp; 컴파일시점에 코드가 생성된다는것을 이용해서, 여러번의 순회(loop),대입이 필요한 연산을 컴파일  시점에 하나의 수식처럼 변환하고, &nbsp;불필요한 임시객체 생성을 막기 위해 RVO (Return Value Optimization)  최적화도 이루에 질수 있게끔 코드를 만들었다.</span></div><div style="font-family: inherit;"><span style="font-size: small;"><br />만약 우리가 행렬을 표현하기 위한 클래스와, 행렬간 덧셈을 위한 연산자 오버로딩을 다음과 같이 구현했다 라고 가정하면,</span></div><div style="font-family: inherit;"><span style="font-size: small;"></span><br /><div style="position: relative;"><div class="highlight" style="background: none repeat scroll 0% 0% rgb(32, 32, 32);"><pre style="-moz-font-feature-settings: normal ! important; -moz-font-language-override: normal ! important; background-color: #1c1c1c; border-radius: 5px 5px 5px 5px; color: #d0d0d0; display: block; font-size-adjust: none ! important; font-stretch: normal ! important; font-style: normal ! important; font-variant: normal ! important; font-weight: normal ! important; line-height: normal ! important; margin: 0px; overflow: auto; padding: 15px;"><span style="font-size: small;"><span style="color: #6ab825; font-weight: normal;">template</span><span style="color: #d0d0d0;">&lt;</span><span style="color: #6ab825; font-weight: normal;">typename</span> <span style="color: #d0d0d0;">T,</span> <span style="color: #d0d0d0;">size_t</span> <span style="color: #d0d0d0;">n,</span> <span style="color: #d0d0d0;">size_t</span> <span style="color: #d0d0d0;">m&gt;</span><br /><span style="color: #6ab825; font-weight: normal;">class</span> <span style="color: #447fcf; text-decoration: underline;">Matrix</span><br /><span style="color: #d0d0d0;">{</span><br /><span style="color: #6ab825; font-weight: normal;">public</span><span style="color: #d0d0d0;">:</span><br />    <span style="color: #d0d0d0;">Matrix(){}</span><br /> <br />    <span style="color: #d0d0d0;">Matrix(</span><span style="color: #6ab825; font-weight: normal;">const</span> <span style="color: #d0d0d0;">Matrix&amp;</span> <span style="color: #d0d0d0;">rhs)</span><br />    <span style="color: #d0d0d0;">{</span><br />        <span style="color: #6ab825; font-weight: normal;">for</span><span style="color: #d0d0d0;">(</span><span style="color: #6ab825; font-weight: normal;">int</span> <span style="color: #d0d0d0;">i=</span><span style="color: #3677a9;">0</span><span style="color: #d0d0d0;">;</span> <span style="color: #d0d0d0;">i&lt;n;</span> <span style="color: #d0d0d0;">++i)</span><br />            <span style="color: #6ab825; font-weight: normal;">for</span><span style="color: #d0d0d0;">(</span><span style="color: #6ab825; font-weight: normal;">int</span> <span style="color: #d0d0d0;">j=</span><span style="color: #3677a9;">0</span><span style="color: #d0d0d0;">;</span> <span style="color: #d0d0d0;">j&lt;m;</span> <span style="color: #d0d0d0;">++j)</span><br />                <span style="color: #d0d0d0;">ElementAt(i,j)</span> <span style="color: #d0d0d0;">=</span> <span style="color: #d0d0d0;">rhs.ElementAt(i,j);</span><br />    <span style="color: #d0d0d0;">}</span><br /> <br />    <span style="color: #d0d0d0;">Matrix&amp;</span> <span style="color: #6ab825; font-weight: normal;">operator</span><span style="color: #d0d0d0;">=(</span><span style="color: #6ab825; font-weight: normal;">const</span> <span style="color: #d0d0d0;">Matrix&amp;</span> <span style="color: #d0d0d0;">rhs)</span><br />    <span style="color: #d0d0d0;">{</span><br />        <span style="color: #6ab825; font-weight: normal;">if</span><span style="color: #d0d0d0;">(</span> <span style="color: #6ab825; font-weight: normal;">this</span> <span style="color: #d0d0d0;">!=</span> <span style="color: #d0d0d0;">&amp;rhs</span> <span style="color: #d0d0d0;">)</span><br />            <span style="color: #6ab825; font-weight: normal;">for</span><span style="color: #d0d0d0;">(</span><span style="color: #6ab825; font-weight: normal;">int</span> <span style="color: #d0d0d0;">i=</span><span style="color: #3677a9;">0</span><span style="color: #d0d0d0;">;</span> <span style="color: #d0d0d0;">i&lt;n;</span> <span style="color: #d0d0d0;">++i)</span><br />                <span style="color: #6ab825; font-weight: normal;">for</span><span style="color: #d0d0d0;">(</span><span style="color: #6ab825; font-weight: normal;">int</span> <span style="color: #d0d0d0;">j=</span><span style="color: #3677a9;">0</span><span style="color: #d0d0d0;">;</span> <span style="color: #d0d0d0;">j&lt;m;</span> <span style="color: #d0d0d0;">++j)</span><br />                    <span style="color: #d0d0d0;">ElementAt(i,j)</span> <span style="color: #d0d0d0;">=</span> <span style="color: #d0d0d0;">rhs.ElementAt(i,j);</span><br />    <br />        <span style="color: #6ab825; font-weight: normal;">return</span> <span style="color: #d0d0d0;">*</span><span style="color: #6ab825; font-weight: normal;">this</span><span style="color: #d0d0d0;">;</span><br />    <span style="color: #d0d0d0;">}</span><br /> <br />    <span style="color: #6ab825; font-weight: normal;">virtual</span> <span style="color: #d0d0d0;">~Matrix()</span> <span style="color: #d0d0d0;">{}</span><br /><br />    <span style="color: #6ab825; font-weight: normal;">const</span> <span style="color: #d0d0d0;">T&amp;</span> <span style="color: #d0d0d0;">ElementAt(size_t</span> <span style="color: #d0d0d0;">n,</span> <span style="color: #d0d0d0;">size_t</span> <span style="color: #d0d0d0;">m)</span> <span style="color: #6ab825; font-weight: normal;">const</span><br />    <span style="color: #d0d0d0;">{</span> <span style="color: #6ab825; font-weight: normal;">return</span> <span style="color: #d0d0d0;">arrData[n][m];</span> <span style="color: #d0d0d0;">}</span><br /> <br />    <span style="color: #d0d0d0;">T&amp;</span> <span style="color: #d0d0d0;">ElementAt(size_t</span> <span style="color: #d0d0d0;">n,</span> <span style="color: #d0d0d0;">size_t</span> <span style="color: #d0d0d0;">m)</span><br />    <span style="color: #d0d0d0;">{</span> <span style="color: #6ab825; font-weight: normal;">return</span> <span style="color: #d0d0d0;">arrData[n][m];</span> <span style="color: #d0d0d0;">}</span><br /><br /><span style="color: #6ab825; font-weight: normal;">private</span><span style="color: #d0d0d0;">:</span><br />    <span style="color: #999999; font-style: italic;">// C-style array for efficiency and locality of reference</span><br />    <span style="color: #d0d0d0;">T</span> <span style="color: #d0d0d0;">arrData[n][m];</span><br /><span style="color: #d0d0d0;">};</span><br /><br /><span style="color: #6ab825; font-weight: normal;">template</span><span style="color: #d0d0d0;">&lt;</span><span style="color: #6ab825; font-weight: normal;">typename</span> <span style="color: #d0d0d0;">T,</span> <span style="color: #d0d0d0;">size_t</span> <span style="color: #d0d0d0;">n,</span> <span style="color: #d0d0d0;">size_t</span> <span style="color: #d0d0d0;">m&gt;</span><br /><span style="color: #d0d0d0;">Matrix&lt;T,</span> <span style="color: #d0d0d0;">n,</span> <span style="color: #d0d0d0;">m&gt;</span> <span style="color: #6ab825; font-weight: normal;">operator</span><span style="color: #d0d0d0;">+(</span>  <span style="color: #6ab825; font-weight: normal;">const</span> <span style="color: #d0d0d0;">Matrix&lt;T,</span> <span style="color: #d0d0d0;">n,</span> <span style="color: #d0d0d0;">m&gt;&amp;</span> <span style="color: #d0d0d0;">lhs,</span><br />                            <span style="color: #6ab825; font-weight: normal;">const</span> <span style="color: #d0d0d0;">Matrix&lt;T,</span> <span style="color: #d0d0d0;">n,</span> <span style="color: #d0d0d0;">m&gt;&amp;</span> <span style="color: #d0d0d0;">rhs</span> <span style="color: #d0d0d0;">)</span><br /><span style="color: #d0d0d0;">{</span><br />    <span style="color: #d0d0d0;">Matrix&lt;T,</span> <span style="color: #d0d0d0;">n,</span> <span style="color: #d0d0d0;">m&gt;</span> <span style="color: #d0d0d0;">matSum;</span><br />    <span style="color: #6ab825; font-weight: normal;">for</span><span style="color: #d0d0d0;">(</span><span style="color: #6ab825; font-weight: normal;">int</span> <span style="color: #d0d0d0;">i=</span><span style="color: #3677a9;">0</span><span style="color: #d0d0d0;">;</span> <span style="color: #d0d0d0;">i&lt;n;</span> <span style="color: #d0d0d0;">++i)</span><br />        <span style="color: #6ab825; font-weight: normal;">for</span><span style="color: #d0d0d0;">(</span><span style="color: #6ab825; font-weight: normal;">int</span> <span style="color: #d0d0d0;">j=</span><span style="color: #3677a9;">0</span><span style="color: #d0d0d0;">;</span> <span style="color: #d0d0d0;">j&lt;m;</span> <span style="color: #d0d0d0;">++j)</span><br />            <span style="color: #d0d0d0;">matSum.ElementAt(i,j)</span> <span style="color: #d0d0d0;">=</span> <span style="color: #d0d0d0;">lhs.ElementAt(i,j)</span> <span style="color: #d0d0d0;">+</span> <span style="color: #d0d0d0;">rhs.ElementAt(i,j);</span><br />    <span style="color: #6ab825; font-weight: normal;">return</span> <span style="color: #d0d0d0;">matSum;</span><br /><span style="color: #d0d0d0;">}</span><br /></span></pre></div></div><span style="font-size: small;"></span></div><div style="font-family: inherit;"><span style="font-size: small;"><br /></span></div><div style="font-family: inherit;"><span style="font-size: small;">그리고 동일한 행과 열을 가진 두 행렬 A, B 를 더하는 경우를 생각해본다.</span></div><div style="font-family: inherit;"><span style="font-size: small;"><br /></span></div><div style="font-family: inherit;"><span style="font-size: small;"></span><br /><div style="background-color: #d0ff9d; padding: 10px;"><span style="font-size: small;">Matrix&lt;double, n, m&gt; S = A + B;</span></div><span style="font-size: small;"></span></div><div style="font-family: inherit;"><span style="font-size: small;"><br /></span></div><div style="font-family: inherit;"><span style="font-size: small;">최적화 없는 경우 임시 객체가 생성되어, S 를 위한 복사생성자를 호출하게 될것이다. 하지만 대부분의 컴파일러는 RVO 최적화를 통해서 임시 객체 대신 S의 저장공간을 활용해 직접 복사 생성 될것이다.&nbsp; 그럼, 컴파일러가 최적화 해주는 경우는 제외하고 다음과 같은 경우를 고려해본다.</span></div><div style="font-family: inherit;"><span style="font-size: small;"><br /></span></div><div style="font-family: inherit;"><span style="font-size: small;"></span><br /><div style="background-color: #d0ff9d; padding: 10px;"><span style="font-size: small;"><span style="color: blue;">Matrix&lt;double, n, m&gt; S ; // 먼저 정의<br />... S 사용<br />S = A + B; // 임시객체 생성</span></span></div><span style="font-size: small;"></span></div><div style="font-family: inherit;"><span style="font-size: small;">이 경우 RVO는 작동 하지 않는다. 대입연산자는 S의 이전 내용을 다른 내용으로 변환 하는 역활을 하며 임시객체가 생성된다. 컴파일러는 먼저 임시객체를 하나 만들어서 루프를 돌면서 A,B 행렬의 값을 더해서 그 임시객체에 대입하고, 대입 연산자에서 두번째로 루프를 돌면서 임시객체로부터 S 에 대입하게 된다. 이것은 시간, 공간적으로 매우 비효율적인 작업이다. 연산이 늘어날수로 임시객체와 루프사용이 점점 늘어나게 되어 성능이 중요한 프로그램등에서는 적합하지 않다. 성능을 위해서는 모든 임시객체의 삭제뿐만 아니라, n x m 횟수만큼 1번만 순회하면서 S 행렬을 만들게 하는 방법이 필요하다.</span></div><div style="font-family: inherit;"><div><span style="font-size: small;"><br /></span></div><div><span style="font-size: small;">바로 이것이 Expression template 이 하는 일이다.</span></div><div><span style="font-size: small;"><br /></span></div><div><span style="font-size: small;">다음처럼 클래스를 수정해보자.</span></div><div><span style="font-size: small;"></span><br /><div><div><span style="font-size: small;"><br /></span></div><div style="background-color: #d0ff9d; padding: 10px;"><div><div><span style="font-size: small;"><span style="color: blue;">template&lt;typename T, size_t n, size_t m&gt;</span></span></div><div><span style="font-size: small;"><span style="color: blue;">class Matrix;</span></span></div><div><span style="font-size: small;"><span style="color: blue;"><br /></span></span></div></div><div><span style="font-size: small;"><span style="color: red;">template&lt;typename T, size_t n, size_t m&gt;</span></span></div><div><span style="font-size: small;"><span style="color: red;">class EtMatrixAdd</span></span></div><div><span style="font-size: small;"><span style="color: red;">{</span></span></div><div><span style="font-size: small;"><span style="color: red;">public:</span></span></div><div><span style="font-size: small;"><span style="color: red;">&nbsp;&nbsp; &nbsp;EtMatrixAdd( &nbsp; &nbsp;const Matrix&lt;T, n, m&gt;&amp; lhs, </span></span></div><div><span style="font-size: small;"><span style="color: red;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const Matrix&lt;T, n, m&gt;&amp; rhs) : m_lhs(lhs), m_rhs(rhs</span></span></div><div><span style="font-size: small;"><span style="color: red;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ) </span></span></div><div><span style="font-size: small;"><span style="color: red;">&nbsp;&nbsp; &nbsp;{</span></span></div><div><span style="font-size: small;"><span style="color: red;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;printf("EtMatrixAdd Constructor! \n");</span></span></div><div><span style="font-size: small;"><span style="color: red;">&nbsp;&nbsp; &nbsp;}</span></span></div><div><span style="font-size: small;"><span style="color: red;"><br /></span></span></div><div><span style="font-size: small;"><span style="color: red;">&nbsp;&nbsp; &nbsp;T ElementAt(size_t nn, size_t mm) const</span></span></div><div><span style="font-size: small;"><span style="color: red;">&nbsp;&nbsp; &nbsp;{ </span></span></div><div><span style="font-size: small;"><span style="color: red;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;printf("EtMatrixAdd ElementAt! \n"); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></span></div><div><span style="font-size: small;"><span style="color: red;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;return m_lhs.ElementAt(nn, mm) + m_rhs.ElementAt(nn, mm); </span></span></div><div><span style="font-size: small;"><span style="color: red;">&nbsp;&nbsp; &nbsp;}</span></span></div><div><span style="font-size: small;"><span style="color: red;"><br /></span></span></div><div><span style="font-size: small;"><span style="color: red;">private:</span></span></div><div><span style="font-size: small;"><span style="color: red;">&nbsp;&nbsp; &nbsp;const Matrix&lt;T, n, m&gt;&amp; m_lhs;</span></span></div><div><span style="font-size: small;"><span style="color: red;">&nbsp;&nbsp; &nbsp;const Matrix&lt;T, n, m&gt;&amp; m_rhs;</span></span></div><div><span style="font-size: small;"><span style="color: red;">};</span></span></div><div><span style="font-size: small;"><span style="color: blue;"><br /></span></span></div><div><span style="font-size: small;"><span style="color: blue;">template&lt;typename T, size_t n, size_t m&gt;</span></span></div><div><span style="font-size: small;"><span style="color: blue;">class Matrix</span></span></div><div><span style="font-size: small;"><span style="color: blue;">{</span></span></div><div><span style="font-size: small;"><span style="color: blue;">public:</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp;Matrix(){}</span></span></div><div></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp;Matrix(const Matrix&amp; rhs)</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp;{</span></span></div><div><span style="font-size: small;"><span class="Apple-tab-span" style="white-space: pre;"><span style="color: blue;">        </span></span><span style="color: blue;">printf("Copy Constructor! \n");</span></span></div><div><span style="font-size: small;"><span style="color: blue;"><br /></span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;for(int i=0; i&lt;n; ++i)</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for(int j=0; j&lt;m; ++j)</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ElementAt(i,j) = rhs.ElementAt(i,j);</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp;}</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp;</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp;Matrix&amp; operator=(const Matrix&amp; rhs)</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp;{</span></span></div><div><span style="font-size: small;"><span class="Apple-tab-span" style="white-space: pre;"><span style="color: blue;"> </span></span><span style="color: blue;">printf("operator = #1! \n");</span></span></div><div><span style="font-size: small;"><span style="color: blue;"><br /></span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;if( this != &amp;rhs )</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for(int i=0; i&lt;n; ++i)</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for(int j=0; j&lt;m; ++j)</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ElementAt(i,j) = rhs.ElementAt(i,j);</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp;</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;return *this;</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp;}</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp;<span style="white-space: pre;">&nbsp;   </span></span></span></div><div><span style="font-size: small;"><span style="color: blue;"><span style="white-space: pre;">    </span><span style="color: #d41a01;">Matrix&lt;T, n, m&gt;&amp; operator=( const EtMatrixAdd&lt;T, n, m&gt;&amp; rhs) </span></span></span></div><div><span style="font-size: small;"><span style="white-space: pre;"><span style="color: #d41a01;">    </span></span><span style="color: #d41a01;">{</span><span class="Apple-tab-span" style="white-space: pre;"><span style="color: #d41a01;"> </span></span></span></div><div><span style="font-size: small;"><span class="Apple-tab-span" style="white-space: pre;"><span style="color: #d41a01;">        </span></span><span style="color: #d41a01;">printf("operator = #2! \n");</span></span></div><div><span style="font-size: small;"><span class="Apple-tab-span" style="white-space: pre;"><span style="color: #d41a01;">  </span></span></span></div><div><span style="font-size: small;"><span class="Apple-tab-span" style="white-space: pre;"><span style="color: #d41a01;"> f</span></span><span style="color: #d41a01;">or(int i=0; i&lt;n; ++i)</span></span></div><div><span style="font-size: small;"><span class="Apple-tab-span" style="white-space: pre;"><span style="color: #d41a01;">     </span></span><span style="color: #d41a01;">for(int j=0; j&lt;m; ++j)</span></span></div><div><span style="font-size: small;"><span class="Apple-tab-span" style="white-space: pre;"><span style="color: #d41a01;">         </span></span><span style="color: #d41a01;">ElementAt(i,j) = rhs.ElementAt(i,j);</span></span></div><div><span style="font-size: small;"><span class="Apple-tab-span" style="white-space: pre;"><span style="color: #d41a01;">   </span></span></span></div><div><span style="font-size: small;"><span class="Apple-tab-span" style="white-space: pre;"><span style="color: #d41a01;"> </span></span><span style="color: #d41a01;">return *this;</span><span class="Apple-tab-span" style="white-space: pre;"><span style="color: #d41a01;">  </span></span></span></div><div><span style="font-size: small;"><span style="white-space: pre;"><span style="color: #d41a01;">    </span></span><span style="color: #d41a01;">}</span></span></div><div><span style="font-size: small;"><span style="color: blue;"><span style="white-space: pre;">                      &nbsp; <span style="white-space: normal;">&nbsp;&nbsp; &nbsp;</span></span></span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp;virtual ~Matrix() {}</span></span></div><div><span style="font-size: small;"><span style="color: blue;"><br /></span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp;const T&amp; ElementAt(size_t nn, size_t mm) const</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp;{ return arrData[nn][mm]; }</span></span></div><div></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp;T&amp; ElementAt(size_t nn, size_t mm)</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp;{ return arrData[nn][mm]; }</span></span></div><div><span style="font-size: small;"><span style="color: blue;"><br /></span></span></div><div><span style="font-size: small;"><span style="color: blue;">private:</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp;// C-style array for efficiency and locality of reference</span></span></div><div><span style="font-size: small;"><span style="color: blue;">&nbsp;&nbsp; &nbsp;T arrData[n][m];</span></span></div><div><span style="font-size: small;"><span style="color: blue;">};</span></span></div><div><span style="font-size: small;"><span style="color: blue;"><br /></span></span></div><div><span style="font-size: small;"><span style="color: red;">template&lt;typename T, size_t n, size_t m&gt;</span></span></div><div><span style="font-size: small;"><span style="color: red;">inline EtMatrixAdd&lt;T, n, m&gt; operator+( &nbsp;const Matrix&lt;T, n, m&gt;&amp; lhs, </span></span></div><div><span style="font-size: small;"><span style="color: red;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const Matrix&lt;T, n, m&gt;&amp; rhs) </span></span></div><div><span style="font-size: small;"><span style="color: red;">{ </span></span></div><div><span style="font-size: small;"><span class="Apple-tab-span" style="white-space: pre;"><span style="color: red;"> </span></span><span style="color: red;">printf("EtMatrixAdd operator +! \n");</span></span></div><div><span style="font-size: small;"><span style="color: red;"><br /></span></span></div><div><span style="font-size: small;"><span style="color: red;">&nbsp;&nbsp; &nbsp;return EtMatrixAdd&lt;T, n, m&gt;(lhs, rhs); </span></span></div><div><span style="font-size: small;"><span style="color: red;">}</span></span></div></div><div><span style="font-size: small;"><br /></span></div><div><span style="font-size: small;">이제 아래의 연산을 수행해보면,</span></div><div><span style="font-size: small;"><span style="color: blue;"></span></span><br /><div style="background-color: #d0ff9d; padding: 10px;"><span style="font-size: small;"><span style="color: blue;">Matrix&lt;double, n, m&gt; S ; // 먼저 정의</span></span><br /><span style="font-size: small;"><span style="color: blue;">... S 사용</span></span><br /><span style="font-size: small;"><span style="color: blue;">S = A + B; </span></span></div><span style="font-size: small;"><span style="color: blue;"></span></span></div><div><span style="font-size: small;"><span style="color: blue;"><span style="color: black;"><br /></span></span></span></div><div><span style="font-size: small;">새로 정의된 + 연산자는 이제 A,B 행렬의 참조자를 가진 EtMatrixAdd 임시객체를 리턴한다. 대입 연산자에서는 순회를 통해 EtMatrixAdd 클래스의 ElementAt 메소드를 호출하여 더하기 연산의 결과를 구한다.ElementAt 메소드는 A,B 행렬의 각 요소의 합을 리턴하고 있다. 이렇게 하면 RVO가 동작함으로서 임시객체도 생성되지 않고, 루프 순회도 1번 동작으로 원하는 더하기 연산이 수행된다. 하지만 아직은 해결책이라고 할수없다.</span></div><div><span style="font-size: small;"><br /></span></div><div><span style="font-size: small;">다음의 경우를 고려해 보자.</span></div><div><span style="font-size: small;"><br /></span></div><div><span style="font-size: small;"><span style="color: blue;"></span></span><br /><div style="background-color: #d0ff9d; padding: 10px;"><span style="font-size: small;"><span style="color: blue;">Matrix&lt;double, n, m&gt; S ; // 먼저 정의</span></span><br /><span style="font-size: small;"><span style="color: blue;">...&nbsp; S 사용</span></span><br /><span style="font-size: small;"><span style="color: blue;">S = A + B + C; </span></span></div><span style="font-size: small;"><span style="color: blue;"></span></span></div><div><span style="font-size: small;">이경우, 컴파일러는 A,B행렬의 더하기에 새로운 + 연산자를 적용할것이다. 그리고 그결과로 EtMatrixAdd 임시객체가 생성될것이다. 즉, 아래의 코드를 작성한것과 동일하게 동작할것이다.</span></div><div><span style="font-size: small;"><br /></span></div><div><span style="font-size: small;"><span style="color: blue;"></span></span><br /><div style="background-color: #d0ff9d; padding: 10px;"><span style="font-size: small;"><span style="color: blue;">EtMatrixAdd&lt;double, n, m&gt; Temp1 = A + B;</span></span></div><span style="font-size: small;"><span style="color: blue;"></span></span></div><div><span style="font-size: small;">그리고 컴파일러는 Temp1 +C 를 위한 코드를 만들려 할것이다. 그결과는 Temp1 ,C 를  참조자로 갖는 Temp2 임시객체가 되야할것이다. 하지만, 지금 EtMatrixAdd 와 matrix 를 위한 + 연산자는  정의된것이 없기때문에 가능하지 않다. 또한 EtMatrixAdd 의 생성자또한 EtMatrixAdd 와 matrix 를 위한것은  정의되있지 않다.</span></div><div><span style="font-size: small;"><br /></span></div><div><span style="font-size: small;">이것을 해결하기 위해, 템플릿 인자를 활용해서 클래스를 수정해보면,</span></div><div><span style="font-size: small;"><br /></span></div><div><div style="background-color: #d0ff9d; padding: 10px;"><div><span style="font-size: small;"><span style="color: blue;">template&lt;typename T, size_t n, size_t m&gt;<br />class Matrix;</span></span></div><div><span style="font-size: small;"><span style="color: black;"><br /></span><span style="color: red;">template &lt;&nbsp; typename T, size_t n, size_t m, typename LeftOp, typename RightOp&gt;<br />class EtMatrixAdd<br />{<br />public:<br />&nbsp; &nbsp; EtMatrixAdd(const LeftOp&amp; lhs, const RightOp&amp; rhs) : m_lhs(lhs), m_rhs(rhs) <br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; printf("EtMatrixAdd Constructor! \n");<br />&nbsp; &nbsp; }</span></span></div><span style="font-size: small;"><span style="color: black;"></span></span><br /><div><span style="font-size: small;"><span style="color: black;"><br /></span></span><span style="font-size: small;"><span style="color: black;"><span style="color: red;">&nbsp; &nbsp; T ElementAt(size_t nn, size_t mm) const<br />&nbsp; &nbsp; { <br />&nbsp; &nbsp; &nbsp; &nbsp; printf("EtMatrixAdd ElementAt! \n"); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; return m_lhs.ElementAt(nn, mm) + m_rhs.ElementAt(nn, mm); <br />&nbsp; &nbsp; }</span></span></span></div><span style="font-size: small;"><span style="color: black;"></span></span><br /><div><span style="font-size: small;"><span style="color: black;"><span style="color: red;">private:<br />&nbsp; &nbsp; const LeftOp&amp; m_lhs;<br />&nbsp; &nbsp; const RightOp&amp; m_rhs;<br />};</span></span></span></div><span style="font-size: small;"><span style="color: black;"></span></span><div><span style="font-size: small;"><span style="color: black;"><br /></span></span><span style="font-size: small;"><span style="color: black;"><span style="color: blue;">template&lt;typename T, size_t n, size_t m&gt;<br />class Matrix<br />{<br />public:<br />&nbsp; &nbsp; Matrix(){printf("Constructor! \n");}</span></span></span></div><span style="font-size: small;"><span style="color: black;"><div><span style="color: blue;">&nbsp; &nbsp; Matrix(const Matrix&amp; rhs)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; printf("Copy Constructor! \n");</span></div><div><br /><span style="color: blue;">&nbsp; &nbsp; &nbsp; &nbsp; for(int i=0; i&lt;n; ++i)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(int j=0; j&lt;m; ++j)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ElementAt(i,j) = rhs.ElementAt(i,j);<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; Matrix&amp; operator=(const Matrix&amp; rhs)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; printf("operator = #1! \n");</span></div><div><br /><span style="color: blue;">&nbsp; &nbsp; &nbsp; &nbsp; if( this != &amp;rhs )<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(int i=0; i&lt;n; ++i)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(int j=0; j&lt;m; ++j)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ElementAt(i,j) = rhs.ElementAt(i,j);<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; return *this;<br />&nbsp; &nbsp; }</span>&nbsp; &nbsp; <br />&nbsp; &nbsp; <span style="color: red;">template&lt; typename TT, size_t nn, size_t mm, typename LeftOp, typename RightOp &gt;<br />&nbsp; &nbsp; Matrix&lt;T, nn, mm&gt;&amp; operator=( const EtMatrixAdd&lt;TT, nn, mm, LeftOp, RightOp&gt;&amp; rhs)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; for(int i=0; i&lt;nn; ++i)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(int j=0; j&lt;mm; ++j)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ElementAt(i,j) = rhs.ElementAt(i,j);</span></div><div><br /><span style="color: red;">&nbsp; &nbsp; &nbsp; &nbsp; return *this; <br />&nbsp; &nbsp; } &nbsp; &nbsp; </span>&nbsp; &nbsp; <br />&nbsp; &nbsp; <span style="color: blue;">virtual ~Matrix() {}</span></div><div><br /><span style="color: blue;">&nbsp; &nbsp; const T&amp; ElementAt(size_t nn, size_t mm) const<br />&nbsp; &nbsp; { return arrData[nn][mm]; }</span></div><div><span style="color: blue;">&nbsp; &nbsp; T&amp; ElementAt(size_t nn, size_t mm)<br />&nbsp; &nbsp; { return arrData[nn][mm]; }</span></div><div><span style="color: blue;">private:<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; T arrData[n][m];<br />};</span></div><div><br /><span style="color: red;">template&lt;typename T, size_t n, size_t m&gt;<br />inline EtMatrixAdd&lt;T, n, m, Matrix&lt;T, n, m&gt;, Matrix&lt;T, n, m&gt; &gt;<br />operator+ ( const Matrix&lt;T, n, m&gt;&amp; lhs,&nbsp; const Matrix&lt;T, n, m&gt;&amp; rhs )<br />{<br />&nbsp; &nbsp; printf("#1 operator +&nbsp; \n");<br />&nbsp; &nbsp; return&nbsp; EtMatrixAdd&lt;T, n, m, Matrix&lt;T, n, m&gt;, Matrix&lt;T, n, m&gt; &gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( lhs, rhs );<br />}</span></div></span><br /><div><span style="color: red;"><br />// 컴파일 시점에 재귀적인 생성자 호출 코드가 생성되며, RVO가 동작하게 된다.<br />template&lt; typename T, size_t n, size_t m, typename LeftOp, typename RightOp &gt;<br />inline EtMatrixAdd&lt; T, n, m, EtMatrixAdd&lt;T, n, m, LeftOp, RightOp&gt;, Matrix&lt;T, n, m&gt; &gt; <br />operator+( const EtMatrixAdd&lt;T, n, m, LeftOp, RightOp&gt;&amp; lhs, <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const Matrix&lt;T, n, m&gt;&amp; rhs ) <br />{<br />&nbsp; &nbsp; printf("#2 operator +&nbsp; \n");<br />&nbsp; &nbsp; return&nbsp; EtMatrixAdd&lt;T, n, m, <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EtMatrixAdd&lt;T, n, m, LeftOp, RightOp&gt;, <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Matrix&lt;T, n, m&gt; &gt; (lhs, rhs) ;<br />}</span></div><div><br /></div><div><span style="color: red;"><span style="color: blue;">int main( int argc, char* argv [ ] )<br />{ &nbsp; &nbsp; &nbsp; &nbsp;</span></span></div><div><span style="color: red;"><span style="color: blue;">&nbsp;&nbsp; &nbsp;Matrix&lt;double, 1, 2&gt; A;<br />&nbsp;&nbsp; &nbsp;Matrix&lt;double, 1, 2&gt; B;<br />&nbsp;&nbsp; &nbsp;Matrix&lt;double, 1, 2&gt; C;<br />&nbsp;&nbsp; &nbsp;Matrix&lt;double, 1, 2&gt; S ;<br />&nbsp;&nbsp; &nbsp;S = A + B + C ;<br />&nbsp;&nbsp; &nbsp;return 0;</span></span></div><div><span style="color: blue;"><span style="color: black;"><span style="color: red;"><span style="color: blue;">}</span>  </span></span></span><br /><div><span style="color: blue;"><span style="color: black;"><span style="color: red;"><span style="color: red;"></span></span></span></span><br /><div><span style="color: blue;"><span style="color: black;"><span style="color: red;"><span style="color: red;"><span style="color: black;"><br /></span></span></span></span></span></div><span style="color: blue;"><span style="color: black;"><span style="color: red;"><span style="color: red;"></span></span></span></span></div><span style="color: blue;"><span style="color: black;"><span style="color: red;"></span></span></span></div></span></div><div><span style="font-size: small;"><br /></span></div><div><div class="imageblock center" style="clear: both; text-align: center;"><span style="font-size: small;"><img alt="사용자 삽입 이미지" src="http://jeremyko.cafe24.com/attach/1/2337303347.jpg" height="279" width="469" /></span></div></div><div><span style="font-size: small;">EtMatrixAdd 에 LeftOp, RightOp 템플릿 인자를 추가함으로서 앞서의 문제를 해결했다. </span></div><div><div><div style="background-color: #d0ff9d; padding: 10px;"><span style="font-size: small;">S = A + B + C;</span></div></div><div><span style="font-size: small;"><br /></span></div><div><span style="font-size: small;">이연산을 위해 컴파일러가 생성되는 코드는 아래처럼 작성한것과 동일하다.</span></div><div><span style="font-size: small;"><br /></span></div><div style="background-color: #d0ff9d; padding: 10px;"><div><span style="font-size: small;">typedef Matrix&lt;double, n, m&gt; Mat;</span></div><div><span style="font-size: small;"><br /></span></div><div><span style="font-size: small;">Temp1 = A + B;</span></div><div><span style="font-size: small;">=&gt; EtMatrixAdd&lt;double, n, m, Mat, Mat&gt;</span></div><div><span style="font-size: small;"><br /></span></div><div><span style="font-size: small;">Temp2 = Temp1 + C;</span></div><div><span style="font-size: small;">=&gt; EtMatrixAdd&lt;double, n, m, &nbsp;EtMatrixAdd&lt;double, n, m, Mat, Mat&gt;, &nbsp;Mat&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></div><div><span style="font-size: small;"><br /></span></div><div><span style="font-size: small;">S = Temp2;</span></div></div></div></div><div><span style="font-size: small;"><br /></span></div><div><span style="font-size: small;"><br /></span><span style="font-size: small;"><code class="cpp plain">S.ElementAt(i, j) = Temp2.ElementAt(i, j); 여기서 = 의 우측 내용은 </code><code class="cpp plain">Temp1.ElementAt(i, j) + C.ElementAt(i, j);</code> 로 해석되고, 이는 다시</span><br /><span style="font-size: small;"><code class="cpp plain">A.ElementAt(i, j) + B.ElementAt(i, j) + C.ElementAt(i, j);</code> 이렇게 전개된다.</span><br /><span style="font-size: small;">그리고 대입 연산 <code class="cpp plain">S = A + B + C 이 일어나게 된다.</code> </span><br /><span style="font-size: small;"><br /></span><span style="font-size: small;">즉, 임시객체 생성을 반복하는것이 아니라, 마치 재귀적인 생성자 호출로 처리되어 결국 임시 객체는 발생하지 않고 (RVO가 작동하기 때문), 대입 연산시에 1번의 순회만을 통해서 원하는 S 를 구할수 있게 된다.</span><br /><span style="font-size: small;"><br /></span><span style="font-size: small;">연산을 템플릿을 활용하여 컴파일 시간에 단순한 수식연산으로 치환할수 있는 점은 c++의 템플릿의 강력함을 잘 보여준다.</span></div><div><span style="font-size: small;"><span style="color: blue;"><br /></span></span></div><div><span style="font-size: small;"><span style="color: blue;"><br /></span></span></div></div><span style="font-size: small;"></span></div><div style="background-color: #c9edff; padding: 10px;"><div><span style="font-size: small;"><span style="color: #177fcd;"><b>&nbsp;References</b><span style="color: #666699;">Dr.Dobb's 저널의 (http://www.ddj.com) </span><a href="http://www.ddj.com/cpp/184401656" target="_blank"><span style="text-decoration: none;"><span style="color: #666699;">Expression template article</span></span></a><span style="color: #666699;">&nbsp;</span></span></span></div><div><div><span style="color: #177fcd; font-size: small;"><a href="http://gpgstudy.com/gpgiki/CppExpressionTemplate">http://gpgstudy.com/gpgiki/CppExpressionTemplate</a></span></div></div></div></div><span style="font-family: inherit; font-size: small;"><span class="EolinBookmarkBtn"></span></span><br /><div style="font-family: inherit;"><span style="font-size: small;"><br /></span></div>