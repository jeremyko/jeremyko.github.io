---
layout: post
title: Git 활용 (기본적인 사용법)
date: '2012-07-18T15:12:00.005+09:00'
author: jeremyko
tags:
- Git
modified_time: '2022-01-07T22:48:34.683+09:00'
blogger_id: tag:blogger.com,1999:blog-7360229670252766698.post-6420339731037857540
blogger_orig_url: https://jeremyko.blogspot.com/2012/07/git.html
---

<p><span style="font-size: small;"><a href="http://gitimmersion.com/" style="color: #274e13;">http://gitimmersion.com/</a><br style="color: #274e13;" />&nbsp;</span><br /><span style="font-size: small;"><a href="http://try.github.com/levels/1/challenges/1" style="color: #274e13;">http://try.github.com/levels/1/challenges/1</a><br /></span><br /><br /><br /><b>* 설정</b>&nbsp; <br /><br /><span style="color: blue;">git config --global user.name "Your Name" </span><br /><span style="color: blue;">git config --global user.email "aaa@bbb.com" </span><br /><br />라인 ending 설정 (윈도우경우)<br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git config --global core.autocrlf true&nbsp;</span><br /><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp; git config --global core.safecrlf true </span><br /><br />인코딩 설정:&nbsp; 윈도우 환경일 경우.<br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git config --global i18n.commitEncoding cp949&nbsp;</span><br /><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp; git config --global i18n.logOutputEncoding cp949&nbsp;</span><br /><br /><span style="color: blue;">&nbsp; &nbsp; 물론 인코딩이 utf8 이라면&nbsp;</span><br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git config --global i18n.commitEncoding utf8&nbsp;</span><br /><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp; git config --global i18n.logOutputEncoding utf8 </span><br /><br /><br />SSH-Key 생성<br /><br />&nbsp;&nbsp;&nbsp; ssh-keygen -t rsa <br /><br /><b>* 추적하지 않을 파일 설정하기</b> <br /><br />&nbsp;&nbsp;&nbsp; .gitighore 파일을 생성, 패턴을 기술.<br /><br />&nbsp;&nbsp;&nbsp; echo "*.security" &gt; .gitingnore <br />&nbsp;&nbsp;&nbsp; <br /><b>* 현 설정 확인</b> <br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git config --list </span><br /><br /><br /><b>* Repository 생성</b><br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git init</span><br /><br /><b>* 상태 확인</b>&nbsp;&nbsp; <br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git status</span> <br />&nbsp;&nbsp;&nbsp; <br /><b>* 변경사항을 staging 하기 </b><br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git add test.c </span><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp; git add . </span><br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; staged 상태 : Git가 변화를 인지한 상태, git add 를 수행하면 됨. <br />&nbsp;&nbsp;&nbsp; 아직 commit을 안한 상태이기때문에 변경사항이 영구적으로 저장된 상태가 아님을 나타냄. <br />&nbsp;&nbsp;&nbsp; <br /><b>* 커밋 </b><br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git commit -m "Changes for a and b"</span><br /><span style="color: blue;">&nbsp; &nbsp; 혹은 vi등 편집기를 통해 메시지 편집 시에는 그냥 git commit </span><br /><br />&nbsp;&nbsp;&nbsp; 주의) 파일 수정후 add, 다시 파일 수정후, commit 을 하면, <br />&nbsp;&nbsp;&nbsp; 2번째 수정 사항은 staging안된 상태이다. <br />&nbsp;&nbsp;&nbsp; 커밋을 해도 2번째 수정 사항은 저장안됨. <br />&nbsp;&nbsp;&nbsp; 이때는 2번째 수정 사항에 대한 add 도 수행하고 그것에 대한 commit도 다시 수행 해야함. <br />&nbsp;&nbsp;&nbsp; <br /><b>* 이력보기 </b><br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git log git log --pretty=oneline --max-count=2 </span><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp; git log --pretty=oneline --since='5 minutes ago' </span><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp; git log --pretty=oneline --until='5 minutes ago' </span><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp; git log --pretty=oneline --author=&lt;your name&gt; </span><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp; git log --pretty=oneline --all </span><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp; git log --pretty=format:\"%h %ad | %s%d [%an]\" --graph --date=short </span><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp; git log --all --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short</span><br /><br />&nbsp;&nbsp;&nbsp; 아직 커밋 안된 상태 에서 변경 사항 알아내기 <br />&nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: blue;">git diff HEAD 파일명</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HEAD란 최종 커밋을 의미.<br /><br />&nbsp;&nbsp;&nbsp; 2개 커밋 간 변경된 파일 목록 조회&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue;">git diff --name-only &lt;commit hash1&gt; &lt;commit hash2&gt;</span><br /><br />&nbsp;&nbsp;&nbsp; 각 commit 별 변경된 파일 목록 조회<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue;">git log --name-status</span><br /><br /><br /><b>* 이전 버전 가져오기</b> <br /><br />&nbsp;&nbsp;&nbsp; git log --all --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; * cdb6848 2012-07-18 | 3 commit (HEAD, v1, origin/master, master) [kojunghyen] <br />&nbsp;&nbsp;&nbsp; * b5cda22 2012-07-18 | 1st [kojunghyen] <br />&nbsp;&nbsp;&nbsp; * 2314983 2012-07-18 | 2 commit [kojunghyen] <br />&nbsp;&nbsp;&nbsp; * ece0e9f 2012-07-18 | first commit [kojunghyen] <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git checkout &lt;hash&gt; </span><br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; ex: git checkout 23149839d82ce5f104aa6fba72b201566da44ec6 <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; 다시 master branch의 최신 버전으로 돌아오려면, <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git checkout master </span><br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; 'master’ is the name of the default branch. <br />&nbsp;&nbsp;&nbsp; By checking out a branch by name, you go to the lastest version of that branch. <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <br /><b>* 태그 붙이기 </b><br /><br />&nbsp;&nbsp;&nbsp; 현재 버전을 v1이라고 하기로 하자. <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue;">git tag v1 </span><br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; 바로 이전 버전을 가져오는 방법 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue;">git checkout v1~1 =&gt; v1^ </span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^ notation to indicate “the parent of v1”&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; 이 이전 버전을 v1-beta라고 태그를 붙이자. <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue;">git tag v1-beta </span><br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /><b>* 태그 조회 </b><br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git tag</span><br /></p><pre class="wp-block-code"><code><b>* 태그 삭제 (로컬) </b>&nbsp;</code></pre><pre class="wp-block-code"><code>   git tag -d </code><code><code>&lt;tag명&gt;</code></code></pre><pre class="wp-block-code"><code><b>* 태그 삭제 (원격) </b>&nbsp;</code></pre><pre class="wp-block-code"><code>   git push --delete origin </code><code><code>&lt;tag명&gt;</code></code></pre><pre class="wp-block-code"><code><code><b>* 태그 삭제 (tag 명이 브랜치명과 같은 경우)</b></code></code></pre><pre class="wp-block-code"><code><code><b>   -&gt; 명시적으로 tag임을 지정해서 삭제해야 함 </b>&nbsp;</code>&nbsp;</code></pre><pre class="wp-block-code"><code><code>   git push origin :refs/tags/&lt;tag명&gt;</code>&nbsp;</code></pre><p><br /><b>* stage-&gt;un-staged 상태로 변경하기 </b><br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git reset HEAD myfile</span><br /><br /><br /><b>* 수정한 내용을 무시하고 처음 상태(최근 커밋된 버전으로)로 되돌리기</b><br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git checkout -- myfile</span><br /><br /><br /><b>* 커밋된 변경 되돌리기 </b><br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git revert HEAD</span> <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; This technique will work with any commit (although you may have to resolve conflicts). <br />&nbsp;&nbsp;&nbsp; It is safe to use even on branches that are publicly shared on remote repositories. <br /><br /><br /><b>* AMENDING COMMITS (커밋 수정하기, 혹은 기존 커밋에 추가하기)</b><br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git commit --amend</span>&nbsp; <br /><br />&nbsp;&nbsp;&nbsp; add, commit된 상태에서 수정이 발생하였고 이전 커밋에 포함하고 싶은 경우(2개의 커밋생성없이). <br /><br /><b>* 여러개의 COMMIT들을 하나의 C OMMIT으로 합치기</b><br />&nbsp;&nbsp;&nbsp; 다음처럼 커밋 히스토리가 존재할때<br />&nbsp;&nbsp;&nbsp; git log --oneline<br />&nbsp;&nbsp;&nbsp; --&gt; <br />&nbsp;&nbsp;&nbsp; commit4<br />&nbsp;&nbsp;&nbsp; commit3<br />&nbsp;&nbsp;&nbsp; commit2<br />&nbsp;&nbsp;&nbsp; first commit<br />&nbsp;&nbsp;&nbsp; 3,4 커밋을 합치고 싶은 경우,<br /><br />&nbsp;&nbsp;&nbsp; git rebase -i HEAD~2<br />&nbsp; &nbsp; pick .......<br />&nbsp;&nbsp;&nbsp; pick .......<br />&nbsp; &nbsp; 이것을 다음 처럼 변경&nbsp; (출력 순서 주의 : 제일 위가 제일 오래된 커밋 이다, git log 와 반대)<br />&nbsp; <br />&nbsp; &nbsp; pick&nbsp;&nbsp;&nbsp;&nbsp; ...<br />&nbsp; &nbsp; squash ... <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br /><b>* MOVING FILES </b><br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git mv hello.rb lib</span><br /><br />&nbsp;&nbsp;&nbsp; 혹은 add 후 제거,<br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git add lib/hello.rb</span><br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git rm hello.rb </span><br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <br /><b>* branch 만들기 </b><br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git checkout -b 브랜치명 </span><br /><br />&nbsp;&nbsp;&nbsp; =&gt; 이후 브랜치내에서 작업을 수행하고 commit한다.<br /><br />&nbsp;&nbsp;&nbsp; 브랜치를 선택할 경우는<br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git branch -a </span><br /><br />&nbsp;&nbsp;&nbsp; =&gt; 브랜치들을 리스트업, 이후 선택할 브랜치를 checkout 하면 됨<br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git checkout master</span><br /><span style="color: blue;"><br /></span><span style="color: blue;">&nbsp;&nbsp;&nbsp; git checkout greet </span><br /><br />&nbsp;&nbsp;&nbsp; <br /><b>* branch 제거 </b><br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git branch -d 브랜치명</span> <br />&nbsp;&nbsp;&nbsp; <br /><br /><b>* Merging</b><br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git checkout greet</span><br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git merge master </span><br /><br />&nbsp;&nbsp;&nbsp; =&gt; master변경분을 greet에 merge시킨다.<br /><br /><br />&nbsp;&nbsp;&nbsp; 예: clean_up branch를 만들고 작업후 master branch로 돌아와서 merge수행시 <br />&nbsp;&nbsp;&nbsp; git merge clean_up <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <br /><b>* branch 변경 비교하기 </b><br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git diff --color branch1..branch2</span><br /><br /><br /><b>* branch내에서 commit간 변경 비교하기 </b><br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git diff --color commit_hash1 commit_hash2</span><br /><br />&nbsp;&nbsp;&nbsp; =&gt; hash 시작 문자 일부만으로도 가능.<br /><br /><br /><b>* 충돌 해소 </b><br /><br />&nbsp;&nbsp;&nbsp; 여러개의 BRANCH간 CHECKOUT시 불일치 발생 경우면 수동으로 해당 파일 수정후 ADD, COMMIT.<br /><br /><br /><b>* branch push/pull 하기</b><br /><br />&nbsp;&nbsp;&nbsp; 자신이 생성한 branch 를 원격저장소에 push<br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git push origin my-branch</span><br /><br /><br />&nbsp;&nbsp;&nbsp; 원격 브랜치 가져오기: 먼저 원격 브랜치 확인<br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git branch -r</span><br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git checkout -b 생성할브랜치이름 원격브랜치이름</span><br /><br />&nbsp;&nbsp;&nbsp; 동일한 이름을 사용한다면 -t 옵션 사용 <br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git checkout --track 원격브랜치이름</span><br /><br /><br /><b>* REBASING VS MERGING</b><br /><br />&nbsp;&nbsp;&nbsp; rebase는 말 그대로 베이스를 다시 잡는 작업이다.<br />&nbsp;&nbsp;&nbsp; 변경사항을 적용할 기준(베이스) 브랜치를 지정하고 현재 브랜치의 변경사항을 <br />&nbsp;&nbsp;&nbsp;&nbsp;그 기준되는 브랜치에 적용을 하여 선형적인 커밋 히스토리를 만들어주므로<br />&nbsp;&nbsp;&nbsp; 지저분하지 않게 된다.<br /><br />&nbsp;&nbsp;&nbsp; 다음설명이 가장 잘 이해됨.<br />&nbsp;&nbsp;&nbsp; Choose to merge when you have a feature on a separate branch and want to bring that<br />&nbsp;&nbsp;&nbsp; code into master or another branch.(feature branch 만들어서 다른branch 와 합칠거면<br />&nbsp;&nbsp;&nbsp; merge 를 사용해라. 즉 일반적인 용도에 사용)<br /><br />&nbsp;&nbsp;&nbsp; Choose to rebase when you want to stay in sync with the main branch<br />&nbsp;&nbsp;&nbsp; when you’re working on a long-lived side branch.(없어지지않고 계속 사용될 branch 와<br />&nbsp;&nbsp;&nbsp; main branch 가 일치된 내용으로 가고싶을경우 rebase를 사용해라)     <br /><br /><span style="color: #0b5394;">&nbsp;&nbsp;&nbsp; 다음 링크에서도 rebase 에 대해서 그림으로 잘 설명됨.</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; <span style="background-color: yellow;">rebase를 사용하지 말자는 내용임</span>. feature branch에서 에러가 발생되면 rebase 시&nbsp;</span><br /><span style="color: #0b5394;">&nbsp;&nbsp;&nbsp; 모든 commit 에 에러가 포함되는 문제를 지적하고 있음.&nbsp;</span><br /><span style="color: #0b5394;">&nbsp;&nbsp;&nbsp; 그냥 간단하게 merge 를 사용하는게 좋다. </span><br /><span style="font-size: small;"><b><span style="color: #0b5394;"><a href="https://medium.com/@fredrikmorken/why-you-should-stop-using-git-rebase-5552bee4fed1" target="_blank"><span face="sans-serif" style="background-color: white; display: inline; float: none; font-style: normal; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px;">&nbsp;&nbsp;&nbsp; https://medium.com/@fredrikmorken/why-you-should-stop-using-git-rebase-5552bee4fed1</span></a></span></b></span><br /><br />&nbsp;&nbsp;&nbsp; When to Rebase, When to Merge? <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Don’t use rebase … 커밋 히스토리를 변경시키기 때문이다. <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://stackoverflow.com/questions/3357122/git-pull-vs-git-fetch-git-rebase" target="_blank">http://stackoverflow.com/questions/3357122/git-pull-vs-git-fetch-git-rebase</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 정확한 커밋 히스토리가 중요한 경우에는 리베이스 사용을 자제.<br />&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp; 하지만 동일한 branch인  경우에는 선택의 여지가 있음 (아래 git pull 참고)<br /><br /><br /><b>* add a remote repository </b><br /><br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git remote add origin git@github.com:jeremyko/try_git.git</span><br /><br /><br /><b>* git fetch </b><br /><br />&nbsp;&nbsp;&nbsp; 원격저장소의 변경사항 가져와서 원격브랜치를 갱신.<br /><br /><br /><b>* Pushing Remotely </b><br /><br />&nbsp;&nbsp;&nbsp; 로컬 변경을 origin repo (on GitHub)에 반영한다. <br />&nbsp;&nbsp;&nbsp; -u 옵션은 입력인자들을 기억하는 옵션이다. <br />&nbsp;&nbsp;&nbsp; 이 경우 다음부터는 git push 만 입력하면 된다. <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git push -u origin master </span><br />&nbsp;&nbsp;&nbsp; <br /><br /><b>* Pulling Remotely </b><br /><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp; git pull </span><br />&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp; remote repository의 변경사항을 가져온다. 그런데 pull명령은 다음과 동일하다. <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git fetch&nbsp;</span><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp; git merge origin/master</span><br /><br />&nbsp;&nbsp;&nbsp; 즉 변경 내용을 가져온후, 로컬의 변경사항과 머지하는작업이 동시에 일어난다.<br /><br />&nbsp; &nbsp; <span style="color: blue;">git pull --rebase</span> <br />&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp; pull 사용 시 매번 merge commit 이 생기는게 필요없는 경우<br />&nbsp;&nbsp;&nbsp; (즉, 동일한 master branch만 pull로 가져오는 경우, master 브랜치끼리 merge commit 은<br />&nbsp;&nbsp;&nbsp;&nbsp; 불필요 할수 있으므로)<br />&nbsp;&nbsp;&nbsp; --rebase 옵션을 주면 merge commit log 가 발생 하지 않게되어,<br />&nbsp;&nbsp;&nbsp; 좀 더 직관적인 이력관리가능. <br />&nbsp;&nbsp;&nbsp; <br /><b>* log&nbsp; </b><br /><br />&nbsp;&nbsp;&nbsp; commit history 로그 보기.<br />&nbsp;&nbsp;&nbsp; 특정 사용자의 commit history 만 보고 싶다면, <span style="color: blue;">git log --author=userid</span><br /><br />&nbsp; &nbsp; 특정 파일에 대한 log를 보고 싶으면, <span style="color: blue;">git log /xxx/yyy/source.hpp</span>&nbsp; &nbsp;  <br /><br /><b>* stash </b><br /><br />&nbsp;&nbsp;&nbsp; 만약 local의 변경 사항을 임시로 저장했다가 나중에 다시 적용하고 싶다면 '<span style="color: blue;">git stash</span>' 로<br />&nbsp;&nbsp;&nbsp; 변경사항을 stash 한 다음, <span style="color: blue;">git stash list</span> 로 목록을 확인할수 있다.<br />&nbsp; &nbsp; 예를 들면, feature branch에서 이슈에 대한 수정을 진행 중인데, master branch로 패치된<br />&nbsp; &nbsp; 내용을 반영하고 작업을 해야 하는 경우, commit 후에 master branch와 merge 할 필요없이<br />&nbsp; &nbsp; stash로 수정사항을 보관 후, master 와 merge 후 다시, 작업 중이던 수정 사항을 반영 하면<br />&nbsp; &nbsp; 다시 이전과 같은 개발 중 상태가 된다.<br />&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp; '<span style="color: blue;">git stash apply</span>' 명령을 pull 작업 이후에 실행해서 재 적용 시킨다.<br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git stash drop</span> 을 수행해야 list 에서 삭제된다.<br />&nbsp;&nbsp;&nbsp; (git statsh apply 대신 <span style="color: blue;">git stash pop</span> 을 수행하면 자동으로 list 에서 삭제된다) <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <br /><b>* cloning </b><br /><br />&nbsp;&nbsp;&nbsp; 원격 저장소에 있는것을 복제하기 위해서는 git clone을 사용한다.<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <span style="color: blue;">git clone </span><span style="color: blue;">https://github.com/jeremyko/kothreadpool.git&nbsp; </span><br /><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp; git clone user@61.40.220.178:/path/rep_name.git my_repo_name</span><br /><br /><b>* Mac 사용시, .DS_Store 파일이 커밋되는것을 막으려면 </b><br /><br />&nbsp;&nbsp;&nbsp; <a href="http://hints.binaryage.com/how-to-remove-ds-store-files-from-a-git-repo/" target="_blank">http://hints.binaryage.com/how-to-remove-ds-store-files-from-a-git-repo/</a><br /><br /><br /><b>* local GIT Server 설정</b><br /><br />&nbsp;&nbsp;&nbsp; 동일한 서버에서 여러 개발자가 개발하는 경우 간단하게 설정 가능.<br />&nbsp;&nbsp;&nbsp; 서버 위치는 /USER/kojh/serverRepository.git 디렉토리라고 가정.<br />&nbsp;&nbsp;&nbsp; 소스 존재 위치는 /USER/kojh/MySrc 라고 가정(이미 git init된 상태).<br /><br />&nbsp;&nbsp;&nbsp; 1. remote 서버 역활 구성<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cd /USER/kojh/serverRepository.git<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue;">git init --bare</span><br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; 2. 소스를 서버에 push<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cd /USER/kojh/MySrc<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue;">git remote add origin /USER/kojh/serverRepository.git</span><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp; </span><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; git push -u origin master</span><br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; 2. 개발자 1 의 작업<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue;">git clone /USER/kojh/serverRepository.git dev1WorkSpace</span><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp; </span><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; git remote add origin /USER/kojh/serverRepository.git</span><br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; 3. 개발자 2 의 작업<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: blue;">git clone /USER/kojh/serverRepository.git dev2WorkSpace</span><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp; </span><br /><span style="color: blue;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; git remote add origin /USER/kojh/serverRepository.git</span><br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; 4. 이제 개발자1,2 가 일반적인 commit, push, pull 을 수행.<br /><br /><br /></p>