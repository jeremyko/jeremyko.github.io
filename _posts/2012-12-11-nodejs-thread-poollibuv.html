---
layout: post
title: node.js 의 thread pool(libuv) 부분
date: '2012-12-11T12:21:00.000+09:00'
author: jeremyko
tags:
- node.js
modified_time: '2012-12-11T12:29:04.363+09:00'
blogger_id: tag:blogger.com,1999:blog-7360229670252766698.post-3741120756531587307
blogger_orig_url: https://jeremyko.blogspot.com/2012/12/nodejs-thread-poollibuv.html
---

<br />node.js 에서의 입출력 동작은 멀티쓰레드(thread pool)로 구현된다.<br />소스 코드에서 이 부분을 정리해본다. 다음과 같이 파일을 비동기로 읽어오는 스크립트가 있을때,<br />함수 호출을 따라가 보면 다음과 같다.<br /><br /><span style="color: #0b5394;">var fs = require('fs');</span><br /><span style="color: #0b5394;">fs.readFile('./bigFile.txt', 'utf8', function(err, data) {</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; console.log(data);</span><br /><span style="color: #0b5394;">});</span><br /><span style="color: #0b5394;">console.log('exiting...');</span><br /><br />사용자의 스크립트에서 호출한 fs.readFile 함수는 /lib/fs.js 에 존재하며<br />내부적으로 다음 함수 호출을 한다.<br /><br /><a name='more'></a><br /><br /><span style="color: #0b5394;">binding.read(fd, buffer, offset, length, position, wrapper);</span><br /><br />node_file.cc 를 보면 javascript 에서 호출한 read 함수는 다음과 같이 정의 되었기 때문에<br /><br /><span style="color: #0b5394;">NODE_SET_METHOD(target, "read", Read);</span><br /><br />결국 C++ 소스의 Read 함수를 호출하게 된다 (<a href="http://jeremyko.blogspot.kr/2012/11/nodejs.html" target="_blank"><b>이전 글 참조</b></a>). Read함수 정의는 다음과 같다.<br /><br /><h4><b><span style="color: #990000;">Read (src/node_file.cc)</span></b></h4><br /><span style="color: #0b5394;">static Handle&lt;Value&gt; Read(const Arguments&amp; args) {</span><br /><span style="color: #0b5394;">&nbsp; HandleScope scope;</span><br /><span style="color: #0b5394;">&nbsp; ...</span><br /><span style="color: #0b5394;">&nbsp; int fd = args[0]-&gt;Int32Value();</span><br /><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">&nbsp; Local&lt;Value&gt; cb;</span><br /><span style="color: #0b5394;">&nbsp; ...</span><br /><span style="color: #0b5394;">&nbsp; pos = GET_OFFSET(args[4]);</span><br /><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">&nbsp; buf = buffer_data + off;</span><br /><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">&nbsp; cb = args[5];</span><br /><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">&nbsp; if (cb-&gt;IsFunction()) {</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; <span style="background-color: #ffe599;">ASYNC_CALL</span>(read, cb, fd, buf, len, pos);</span><br /><span style="color: #0b5394;">&nbsp; } else {</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; SYNC_CALL(read, 0, fd, buf, len, pos)</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; Local&lt;Integer&gt; bytesRead = Integer::New(SYNC_RESULT);</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; return scope.Close(bytesRead);</span><br /><span style="color: #0b5394;">&nbsp; }</span><br /><span style="color: #0b5394;">}</span><br /><br />비동기 호출을 하는경우, 콜백이 존재하고 이때 ASYNC_CALL 매크로로 처리된다.<br /><br /><h4><b><span style="color: #990000;">ASYNC_CALL &nbsp;(src/node_file.cc)</span></b></h4><br /><span style="color: #0b5394;">#define ASYNC_CALL(func, callback, ...) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; FSReqWrap* req_wrap = new FSReqWrap(#func); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; int r = uv_fs_##func(uv_default_loop(), &amp;req_wrap-&gt;req_, &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; __VA_ARGS__, After); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; req_wrap-&gt;object_-&gt;Set(oncomplete_sym, callback); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; req_wrap-&gt;Dispatched(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; if (r &lt; 0) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; uv_fs_t* req = &amp;req_wrap-&gt;req_; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; req-&gt;result = r; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; req-&gt;path = NULL; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; req-&gt;errorno = uv_last_error(uv_default_loop()).code; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; After(req); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; return scope.Close(req_wrap-&gt;object_);</span><br /><br />이 매크로 내부에서 read 요청은 libuv 함수 <span style="background-color: #ffe599;">uv_fs_read</span>호출로 변경된다.<br /><br /><h4><b><span style="color: #990000;">uv_fs_read &nbsp;(deps/uv/src/unix/fs.c)</span></b></h4><br /><span style="color: #0b5394;">int uv_fs_read(uv_loop_t* loop, uv_fs_t* req,</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uv_file file,</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;void* buf,</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;size_t len,</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int64_t off,</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uv_fs_cb cb) {</span><br /><span style="color: #0b5394;">&nbsp; INIT(READ);</span><br /><span style="color: #0b5394;">&nbsp; req-&gt;file = file;</span><br /><span style="color: #0b5394;">&nbsp; req-&gt;buf = buf;</span><br /><span style="color: #0b5394;">&nbsp; req-&gt;len = len;</span><br /><span style="color: #0b5394;">&nbsp; req-&gt;off = off;</span><br /><span style="color: #0b5394;">&nbsp; POST;</span><br /><span style="color: #0b5394;">}</span><br /><br />먼저 INIT처리, 이후 POST 처리를 하고 있다.<br /><br /><h4><b><span style="color: #990000;">INIT&nbsp;</span></b><b><span style="color: #990000;">(deps/uv/src/unix/fs.c)</span></b></h4><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">#define INIT(type) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; do { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; uv__req_init((loop), (req), UV_FS); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; (req)-&gt;fs_type = UV_FS_ ## type; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; (req)-&gt;errorno = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; (req)-&gt;result = 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; (req)-&gt;ptr = NULL; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; (req)-&gt;loop = loop; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; (req)-&gt;path = NULL; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; (req)-&gt;new_path = NULL; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; (req)-&gt;cb = (cb); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; while (0)</span><br /><br /><h4><b><span style="color: #990000;">POST&nbsp;</span></b><b><span style="color: #990000;">(deps/uv/src/unix/fs.c)</span></b></h4><br /><span style="color: #0b5394;">#define POST &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; do { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; if ((cb) != NULL) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; <span style="background-color: white;"><b>uv__work_submit</b></span>((loop), &amp;(req)-&gt;work_req, uv__fs_work, uv__fs_done); &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; return 0; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; else { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; uv__fs_work(&amp;(req)-&gt;work_req); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; uv__fs_done(&amp;(req)-&gt;work_req); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; return (req)-&gt;result; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; while (0)</span><br /><br /><span style="background-color: white;">여기서 thread pool 로 처리가 되기 위한 </span><b style="background-color: #fff2cc;">uv__work_submit</b><span style="background-color: white;"> 함수 호출을 볼수 있다.</span><br /><br /><h4><b><span style="color: #990000;">uv__work_submit &nbsp;(deps/uv/src/unix/threadpool.c)</span></b></h4><br />이 함수는 초기화 작업이 한번만 수행되도록 &nbsp;pthread_once 를 호출하였다. 이 초기화 작업에 쓰레드 풀을 생성하는것이 포함된다.<br /><br /><span style="color: #0b5394;">void uv__work_submit(uv_loop_t* loop,</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;struct uv__work* w,</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;void (*work)(struct uv__work* w),</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;void (*done)(struct uv__work* w)) {</span><br /><span style="color: #0b5394;">&nbsp; pthread_once(&amp;once, init_once);</span><br /><span style="color: #0b5394;">&nbsp; w-&gt;loop = loop;</span><br /><span style="color: #0b5394;">&nbsp; w-&gt;work = work;</span><br /><span style="color: #0b5394;">&nbsp; w-&gt;done = done;</span><br /><span style="color: #0b5394;">&nbsp; post(&amp;w-&gt;wq);</span><br /><span style="color: #0b5394;">}</span><br /><br /><h4><b><span style="color: #990000;">init_once &nbsp;</span></b><b><span style="color: #990000;">(deps/uv/src/unix/threadpool.c)</span></b></h4><br />다음처럼 &nbsp;threads 배열의 크기만큼 쓰레드 풀을 생성하고 있다.<br />linux/mac 의 경우 쓰레드풀을 위해 고정된 쓰레드수가 4로 지정되어 있다.<br />windows 경우는 OS 차원의 쓰레드풀을 활용하므로(QueueUserWorkItem 호출)<br />이런 고정 갯수는 존재하지 않는다.<br /><br /><span style="color: #0b5394;">static pthread_t threads[4];</span><br />...<br /><span style="color: #0b5394;">static void init_once(void) {</span><br /><span style="color: #0b5394;">&nbsp; unsigned int i;</span><br /><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">&nbsp; ngx_queue_init(&amp;wq);</span><br /><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">&nbsp; for (i = 0; i &lt; ARRAY_SIZE(threads); i++)</span><br /><span style="color: #0b5394;">&nbsp; &nbsp;<span style="background-color: #fff2cc;"> if (pthread_create(threads + i, NULL, worker, NULL))</span></span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; abort();</span><br /><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">&nbsp; initialized = 1;</span><br /><span style="color: #0b5394;">}</span><br /><br /><h4><b><span style="color: #990000;">post&nbsp;</span></b><b><span style="color: #990000;">(deps/uv/src/unix/threadpool.c)</span></b></h4><b><br /></b>여기서는 큐에 작업을 넣고, 조건변수에 신호를 보낸다.<br /><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">static void post(ngx_queue_t* q) {</span><br /><span style="color: #0b5394;">&nbsp; pthread_mutex_lock(&amp;mutex);</span><br /><span style="color: #0b5394;">&nbsp; ngx_queue_insert_tail(&amp;wq, q);</span><br /><span style="color: #0b5394;">&nbsp; pthread_cond_signal(&amp;cond);</span><br /><span style="color: #0b5394;">&nbsp; pthread_mutex_unlock(&amp;mutex);</span><br /><span style="color: #0b5394;">}</span><br /><br />한편, 이 thread pool에서 작업을 처리하는 쓰레드 함수는 다음과 같다.<br />큐에 작업이 삽입될때 까지 조건변수를 기다리고 신호를 받으면 작업큐에서 가져와서 처리한다.<br /><br /><span style="color: #0b5394;">static void* worker(void* arg) {</span><br /><span style="color: #0b5394;">&nbsp; struct uv__work* w;</span><br /><span style="color: #0b5394;">&nbsp; ngx_queue_t* q;</span><br /><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">&nbsp; (void) arg;</span><br /><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">&nbsp; for (;;) {</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; if (pthread_mutex_lock(&amp;mutex))</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; abort();</span><br /><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">&nbsp; &nbsp; while (ngx_queue_empty(&amp;wq))</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; if (pthread_cond_wait(&amp;cond, &amp;mutex))</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; &nbsp; abort();</span><br /><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">&nbsp; &nbsp; q = ngx_queue_head(&amp;wq);</span><br /><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">&nbsp; &nbsp; if (q == &amp;exit_message)</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; pthread_cond_signal(&amp;cond);</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; else</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; ngx_queue_remove(q);</span><br /><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">&nbsp; &nbsp; if (pthread_mutex_unlock(&amp;mutex))</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; abort();</span><br /><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">&nbsp; &nbsp; if (q == &amp;exit_message)</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; &nbsp; break;</span><br /><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">&nbsp; &nbsp; w = ngx_queue_data(q, struct uv__work, wq);</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; w-&gt;work(w);</span><br /><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">&nbsp; &nbsp; uv_mutex_lock(&amp;w-&gt;loop-&gt;wq_mutex);</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; ngx_queue_insert_tail(&amp;w-&gt;loop-&gt;wq, &amp;w-&gt;wq);</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; uv_mutex_unlock(&amp;w-&gt;loop-&gt;wq_mutex);</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; uv_async_send(&amp;w-&gt;loop-&gt;wq_async);</span><br /><span style="color: #0b5394;">&nbsp; }</span><br /><span style="color: #0b5394;"><br /></span><span style="color: #0b5394;">&nbsp; return NULL;</span><br /><span style="color: #0b5394;">}</span><br /><br /><h4><b><span style="color: #990000;">ngx_queue_insert_tail &nbsp;(deps/uv/include/uv-private/ngx-queue.h)</span></b></h4><br />큐에 작업을 넣는 부분은 다음과 같이 구현된다. &nbsp;리스트를 이용해서 큐를 구현하였다.<br /><br /><span style="color: #0b5394;">#define ngx_queue_insert_tail(h, x) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; do { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; (x)-&gt;prev = (h)-&gt;prev; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; (x)-&gt;prev-&gt;next = x; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; (x)-&gt;next = h; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; &nbsp; (h)-&gt;prev = x; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</span><br /><span style="color: #0b5394;">&nbsp; } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span><br /><span style="color: #0b5394;">&nbsp; while (0)</span><br /><br />소스를 따라가면 누구나 알수 있는 내용이지만, 한번 간단히 요약해 보았다.<br /><span style="color: #0b5394;"><br /></span>